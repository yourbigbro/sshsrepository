1、git中远程仓库的内容可以直接拉到eclipse的工作区中，但是eclipse工作区中的内容不能直接提交到git远程仓库，只能先提交到本地仓库。


2、创建git仓库的三种方法：
   1）用命令的方式创建git版本仓库：右键--Git Bash Here--输入git init命令（git版本仓库就是.git隐藏文件）
   2）右键--Git在这里创建版本仓库--在制作纯版本库（没有工作目录）上打钩--确定（没有.git隐藏文件，没有目录，直接就是仓库（也就是.git隐藏文件中的内容））
   3）右键--Git在这里创建版本仓库--不在制作纯版本库（没有工作目录）上打钩--确定（有.git隐藏文件）


3、git操作文件：
   1）将文件添加到git管理：（原理是先将工作区中的内容提交到暂存区，再将暂存区中的内容提交到本地git仓库）在目标文件上右       键--TortoiseGit(T)--添加--文件上出现加号--在文件上右键--Git提交--添加日志信息--确认--文件上出现对号，添加成功
   2）修改文件之后提交到git仓库：在文件上右键--Git提交--添加日志信息--确认
   3）查看日志：在目标文件上右键--TortoiseGit(T)--显示日志
   4）修改之后比较差异：在目标文件上右键--TortoiseGit(T)--比较差异--有加号的代码行就是新增的
   5）将文件还原到上一个版本：在目标文件上右键--TortoiseGit(T)--还原
   6）删除git中管理的文件：
      1）在目标文件上右键--TortoiseGit(T)--删除（同时删除了仓库中的文件和本地文件）
      2）在目标文件上右键--TortoiseGit(T)--删除并保留本地副本--文件上出现叉号（保留了本地文件）


4、git管理java项目：
   不提交bin文件夹，因为里面是编译之后的二进制文件。在bin文件夹上右键--TortoiseGit(T)--删除并添加到忽略列表--bin-递归     忽略文件或目录--.gitignore放在文件/文件夹所在的目录--确定（操作的结果是java项目中出现了一个.gitignore文本文件，里面   是被忽略的   bin文件夹，这使得其他人在提交项目时也无法提交bin文件夹）


5、linux命令ll和ls的区别：
   ll是会显示当前目录下的文档详细信息（包括权限、所属用户和组、大小、时间、名称等），是ls -l的缩写，相当于windows的快   捷方式；ls只显示当前目录下的文档名。


6、打pom包的情形：
                1）管理maven依赖的父工程
                2）聚合工程父工程

   打war包的情形：需要部署tomcat。打war包的工程有web.xml配置文件。

   打jar包的情形：被其他项目引用的情况。可以用排除法，也就是只要既不是pom包又不是war包就是jar包。
总之，从上到下依次是pom,jar,war。


7、创建maven工程的四个步骤：创建工程，添加依赖，配置文件，静态页面。


8、配置tomcat端口号的两个方法：
                             1）pom.xml里面，在build--plugins--plugin元素里面添加configuration元素，再在configuration元素里面添加port和path元素。
                             2）conf文件夹里面的server.xml里面配置


9、SqlMapCofig当配置文件为空时是可以没有的。


10、聚合工程父工程下的子工程会首先汇集到父工程然后再执行，因此配置文件可以随便放，最后总会到父工程里面被所有的工程所用。可以统一放在war工程里面看起来更清晰一些。


11、当使用dubbo之后，@Service注解分为阿里巴巴的注解和spring原生的注解，前者在使用事物时会出问题，所以还是用原生的注解。


12、如果需要跳转页面，就需要走视图解析器，就一定不能加@ResponseBody注解。假如既需要跳转页面又需要将java对象转换成json，那么就要在后台手动将java转换成json，然后封装进model返回前台页面。
    如果需要返回数据，就需要走转换器，就一定要加@ResponseBody注解。
    区分视图解析器和转换器。


13、Maven中是有配置文件的，在conf/settings.xml中。该配置文件中配置了maven仓库的路径。


14、add dependency是添加依赖，add plugin是不知道。。


15、controller层依赖service接口只是使得前者可以调用后者，但仍然会报错，因为需要开启服务前者才能真正调用后者。


16、@ResponseBody注解的作用：
                           1）转换数据类型
                           2）还有避免走视图解析器。因此即使不需要转换数据类型也要加上该注解


17、打包install的顺序：父子关系的只打父包就行了（但是只有maven module的才不需要给子模块打包，maven project的仍然需要给子项目打包），依赖关系的先打包被依赖项目再打包依赖项目。顶级项目也需要打包。


18、使混乱的代码对齐的方法：
                          1）右键--source--format
                          2）ctrl+shift+f


19、加上、去掉注释：ctrl+shift+c


20、alt+shift+j给方法添加注释。光标需要在方法名上。


21、当前台传来的参数只有一个并且是简单数据类型时，用${}时必须是value，用#{}则随意，只要不为空就行。


22、sellect * from `user` where `name` like '%${value}%'中，要注意前面的两个不是单引号。


23、通用mapper的输入参数可以省略，输出参数resultType不能省略。


24、.gitignore中应该忽略的文件为：/target/、.settings、.project、.classpath。
               应该提交的文件夹为：src、pom.xml


25、将eclipse中的项目放入远程git私服的流程为：
                                           1）右键--team--share project（项目上出现了问号，放入了工作空间。此时在git窗口编辑.gitignore配置文件）
                                           2）右键--team--add to index（项目上出现了星号，放入了暂存区）
                                           3）右键--team--commit（项目上出现了柱形，放入本地仓库）
                                           4）右键--team--push branch master（仍然是柱形，放入了远程仓库）


26、将eclipse中git页面中下载好的工程导入到开发界面中的方法：右键--import projects--import as general project--定义工程名--确定。--------但是此时eclipse并不知道这是个什么类型的项目，因此在项目上（前提是这是一个maven项目的话）：右键--configure（这个单词翻译成配置）--convert to maven project。


27、eclipse中的git解决冲突的两种方法：
                                    1）在冲突的类文件上右键--team--merge tool（merge翻译成融入）

                                    2）修改之后在冲突的类文件上右键--team--add to index。这样之后项目上就有了星号，然后再提交到本地仓库，最后再提交到远程仓库即可。


28、git的右键--team中那几个提交和拉取的区别是什么？？？？？？？


29、只有war项目中中有web.xml文件，只有pom项目中有pom.xml文件。tomcat（包括tomcat端口）是配置在pom.xml文件中的。端口的port元素下面还可以设置path元素来控制访问路径，设置了port之后就不能再在访问路径里面加项目名。


30、linux进入文件：vim+文件名。开启编辑：i。退出编辑：esc+ctrl+zz


31、dubbo改造的方法：分别在服务端和客户端的application-*.xml中添加dubbo约束和配置dubbo暴露端口。


32、zookeeper和dubbo的关系：zookeeper是dubbo的三种连接方式之一。zookeeper的配置方法是分别在服务端和客户端的application-*.xml中进行配置。zookeeper注册中心的作用是注册服务和查找服务。zookeeper是需要开启服务的，不是配置完了打开虚拟机就完事了，光打开虚拟机不行。


33、@RequestMapping("test/{page}/{rows}")里面的字符串里面有{}，但是和他对应的@Pathvariable("page")里面就没有{}。另外，里面还可以有参数为method=RequestMethod.get。不写的话get和post都可以。


34、本地hosts文件（或DNS）与ngnix反向代理服务器配合的过程：域名--hosts文件--域名和ip地址（注意这里的ip地址是不带端口的）--根据ip地址找到ngnix反向代理服务器，并让ngnix反向代理服务器通过域名映射到带端口的ip地址。


35、@RequestParam(value="要接收的前台传来的属性名",defaultValue="该属性名没有属性值时的默认值")


36、@RequestParam和@PathVariable的应用场景区别在于前者的url格式为...?a=1，后者的url格式为.../1


37、当pom.xml文件里面设置path元素时，url中不写项目名，前台页面的js,css等资源的相对路径正常写或者根据@RequestMapping()加上几个../都行；当没有path元素时，不仅访问的url要写项目名，前台引入的css等资源的相对路径还要根据@RequestMapping()注解加上../。注解中总共有几个层级就要加上几个../。因此，应该在pom.xml文件中加上path元素，这样就不用一直修改css等资源的相对路径，也不用将它们修改成绝对路径。


38、打开多个ngix的时候再访问项目会报错。由于打开nginx不管成功还是失败都是黑框一闪，所以不打开任务管理器的话就无法轻松地看见nginx是否已经启动了以及是否启动了多个。


39、查看端口占用情况的命令：netstat -ano
    nginx的三个命令：start nginx.exe   nginx.exe -s stop   nginx.exe -s reload


40、当直接输入目标的ip地址和端口号时，就不走反向代理和hosts文件了，直接到达目标。输入域名和端口号时，只走hosts文件（为了获得目的地的ip地址）不走反向代理（因为已经有了端口号，不必从nginx中获得端口号）。因此nginx配置文件nginx.conf中的listen对应的端口号只能是默认端口号80，为了在域名后面不输入端口号时从nginx中获得真正的前台Controller地址。并且用于输入的端口绝不可能是80，因为这样的话就不走反向代理了，而真正的端口号为了不和listen的80重合而必然不是80，因此用户输入80端口号的话永远是404找不到页面错误。


41、hosts文件中映射的是域名和ip地址，是没有端口在里面的。

42、当重新配置了nginx的配置文件nginx.conf之后，需要对nginx进行reload，但是项目不用重新开启。该配置文件中将listen（也就是监听）的属性值设置为80是因为浏览器中当不输入端口时默认是80，而listen也监听的是80就使得用户不用在url中输入端口。事实上，一旦输入端口就不会再走nginx了。


43、zookeeper每增加一个接口就要在application-service.xml和application-dao.xml中分别多配置一个dubbo元素用来注册服务和查找服务


44、在eclipse中配置tomcat图片服务器的方式（也就是配置保存图片的路径）：双击tomcat服务器--modules--add web module--配置path。这样的话，将图片存入到该path路径时就会将图片存入webapps文件夹下。


45、将项目安装到本地仓库：右键--run as--maven install。


46、反斜杠的转义问题解决方法：
                            1）改成正斜杠
                            2）再加一个反斜杠


47、选中接口之后ctrl+t查看它的实现类


48、.properties配置文件要被spring加载，也就是需要在.xml文件里面：
                                               <context property-placeholder location="classpath:**/**.properties" />
在代码中使用该配置文件中的键值对的方法是：
                                         @Value("${aa}")
                                         private String aa;


49、网络的状态发生变化时（比如网卡被修改了）dubbo就可能出问题，比如找不到已经发布的服务。解决方式是重新启动作为dubbo服务端的项目。


50、序列化：将对象的状态信息转换成可以存储或传输的过程。传递对象传递的其实是对象的引用，也就是对象的内存地址，无法在项目之间传递。字符串可以传递是因为字符串已经在内部做了序列化。


51、zookeeper的启动方式：
                        进入bin目录启动zookeeper：
                                                [root@itcast-01 bin]# pwd
                                                /usr/local/zookeeper-3.4.6/bin
                                                [root@itcast-01 bin]# ./zkServer.sh start  


52、linux回到根目录：cd /root


53、SEO静态化之后经过过滤器*.html的index.html能够进入index.jsp是因为在前端过滤器去掉了.html之后就只剩下了index，再用springmvc.xml中的视图解析器加上前缀和后缀之后就可以通过返回接收的参数字符串而直接跳转到相应的jsp页面。SEO搜索引擎优化是为了提高页面在搜索引擎中的权重，从而更靠前。


54、为了后台代码容易写，可以将json变成自己创建的pojo，或者map。毕竟都属性和属性值的形式。假如有多个map，还可以将这些map放在list集合中。


55、每次修改代码之后都要重新打包，但是引入依赖却只需要一次。


56、用private static final ObjectMapper MAPPER = new ObjectMapper();和String json = MAPPER.writeValueAsString(picUploadResult);将pojo或集合转换成json是变成了字符串格式的json，因此返回类型是String。


57、redis的两种持久化方案：
                         1）RDB快照：把内存中的数据来一份一摸一样的放在硬盘中。优点是数据量小，节省空间，因为只保存当前数据库的状态不保存增删改的                                     记录。缺点是在数据量大的情况下会出现卡顿，但是还原的所用的时间短。
                         2）AOF命令保存日志：将每一条对redis的写操作命令，保存到类似日志文件中。缺点是需要的空间大，优点是加载到内存中的时候可以                                             一条一条的执行，不会出现卡顿。但是还原的时间会比较长。AOF的另一个优点是可以利用日志修改误操作，再执                                             行一遍十分方便。


58、linux3.0以上才支持集群。


59、pwd：显示当前完整目录名。


60、vim 文件名 表示要修改某个文件。


61、在文件里面/***表示要在文件中寻找字符串***。假如找到多个符合要求的字符串，按n表示跳到下一个符合要求的字符串。


62、shift zz命令为保存退出。


63、ctrl c结束程序


64、select 0表示选择第一个redis数据库。


65、创建shell脚本：vim ****.sh--编写shell脚本--保存退出--./*****.sh来执行该脚本。wxr中w表示可写，x表示可执行，r表示可读。没有权限时会显示-。此时该脚本的权限为默认的读和写，要手动添加执行权限：chmod u+x *****.sh。有执行权限之后文件夹的颜色由白色变为绿色。


66、使用命令行从redis客户端连接redis集群：./redis-cli -h 192.168.37.131 -p 7006 -c。注意，连接主从节点均可。注意，比连接非集群的redis多了一个-c。（c是集群cluster的首字母）


67、expire a 100 将以a为键的键值对（也就是redis数据库中的键值对）的有效期设置为100s。


68、jedisCluster连接池和jedis连接池不一样的地方是前者不用从连接池中取出连接和将连接还给连接池。他是内部集成好的。事实上jedisCluster是连接对象，不    叫连接池。


69、将配置写在xml配置文件而不是在代码里面写注解的原因：不用重新编译和部署。


70、restful接口风格的五个特点：
                             1）使用http或https协议
                             2）使用专用的域名
                             3）路径中不能有动词只能有名词，名词往往与数据库表格名字相对应
                             4）用http动词进行资源操作（常用的四个是get,post,put,delete）
                             5）用json作为返回数据的格式
                             6）不要使用大写字母
                             7）用中线-代替下划线_
                             8）参数列表被encode过（防止中文参数产生乱码）


71、最佳实践：最佳实践最好应该使用的开发方式，包括使用restful风格的接口和响应设计。restful风格的接口上面介绍过了，相应设计的最佳实践如下：
                      1）响应体仅仅用来传输数据，不要有状态码等其他内容。
                      2）数据要拿来就可以用，不要拆箱（例如不要嵌套json等）
                      3）用来描述数据或者请求的元数据放在header中（也就是响应头中）。（元数据就是描述数据的数据）


72、开发接口的工具：谷歌浏览器里面的Advanced REST client


73、当一台服务器上有多个服务时（也就是有多个service时），zookeeper的端口不用改，dubbo的端口号20880要改，不然会冲突。但是如果使用的是分布式，也就是每个服务都不在一个服务器上的话，就不用改端口号了。


74、web.xml中配置spring（也就是applicationContext.xml文件的路径）和spring监听器。


75、不能同时开启redis配置和redis集群配置不是因为他们都继承的一个接口，而是我们调用的是接口，因此一个接口此时无法对应两个实现类。


76、判断字符串是否为null或者""空字符串的方法：StringUtils.isNotBlank()


77、对象和字符串的相互转换：
                           private static final ObjectMapper MAPPER =new ObjectMapper();
                           1）将对象转换为字符串：String str = MAPPER.writeValueAsString(对象);
                           2）将字符串转换为对象：User user = MAPPER.readValue(str,User.class);


78、在eclipse里面ctrl+h---选择file search 可以进行关键字的搜索。containing text是你要搜索的内容，file name patterns是你要搜索的文件，可以用模糊匹    配。
    ctrl+h是跳转到该文件的指定行数。


79、java的md5加密使用apache包的DigestUtils.md5Hex()方法。


80、redis保证唯一性的方法：incr(aaa)方法，作用是将aaa的值加一。


81、ticket的作用：ticket在用户登陆成功之后存储在cookie中，可以根据ticket从redis数据库中查询到用户的登录信息，从而在分布式集群中不用一直登陆，也可以在用户购物时将用户信息写入订单等位置。


82、linux命令的mv 文件名A 文件名B时代表将文件重命名而不是移动文件。


83、solr索引中，index域查询document域，document域里面有document，document里面有field域。当某个filed域的是否存储选项为否时（也就是field元素的stored属性），他不会出现在field域里面。


84、分词，索引，存储的关系（配置业务域时要使用）：不分词也可能索引，例如价格；索引了也可能不存储，因为可以根据他搜索但是不会展示；不索引也可能存储；不索引的必然不分词，因为分词是为了索引，不索引当然就不用分词了。假如不分词，field业务域中的type是数据类型，分词的话属性值就是分词器名称。另外，业务域的id不能重复。


85、oracle和mysql的区别：前者是基于用户的，后者是基于数据库的。前者是先创建用户再创建表，后者是先创建数据库再创建表。


86、solr单机版和集群版的区别在于后者需要先连接zookeeper再连接solr的collection信息集合。


87、solr的两个分片虽然是分布式，存储的信息是不同的，但是不管从那个分片进行查询，返回的数据都包含所有（分片）的数据。


88、请求进入springmvc的时候会在控制台中显示出来。


89、从数据库中查询数据并添加到索引库的步骤：
                                          1）用mapper从数据库中查询数据
                                          2）把数据封装到SolrInputDocument中（根据schema.xml配置文件中配置的field用addField方法进行封装进行封装）
                                          3）用CloudSolrServer将数据添加到索引库中（调用add方法传入参数SolrInputDocument然后调用commit方法提交）


90、nginx的三个作用：反向代理，图片服务器（文件服务器），集群（可以做到负载均衡）。其中反向代理和图片服务器都是配置映射路径。


91、eclipse里面alt+回车可以显示文件夹的路径


92、防止sql注入的三种方法：页面，服务器，数据库。其中，页面是将关键词替换掉，服务器是将${}变为#{}。
    防止js注入的方法：替换掉关键词，也就是替换掉元素标签（转义掉尖括号。元素名称并不替换）。


93、spring boot省去了java部署的环节，放到服务器上java -jar启动即可（因为里面集成了tomcat）。传统是war部署方式，需要部署到tomcat里面。


94、springboot是spring的一个子项目，能够简化开发，但是该用什么技术还是用什么技术，依然要用到spring。


95、寻找maven的配置文件位置：window--preference--maven--user settings


96、注解和继承的接口重名时（例如springboot的mapper和继承的通用mapper接口）必须有一个是全路径以示区分。


97、分页助手和通用mapper配置在SqlMapConfig.xml中，即使是springboot也要配置。


98、web3.0和2.5的区别在于前者不再有web.xml，也就是没有webapps文件夹。页面资源应该放在那个resources资源文件夹，访问页面时不用再像以前一样从controller跳转，而是直接访问页面即可，页面会调用后台接口，也就是自动访问Controller中的方法。


99、计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母b表示。而计算机最小的存储单元叫“字节（byte）”，通常用大写字母B表示，字节是由连续的8个位组成。


100、基本类型在-128~127的话会在常量池里面，包装类型例如Integer就不行了。


101、栈 存储局部变量
     堆 存储new出来的东西（新new出来的未赋值的数组，基本类型默认为0，引用类型默认为null）
     方法区:
            1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。
            2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。 


102、方法重载特点:与返回值类型无关，只看方法名和参数列表。只要方法名相同并且参数列表不行同，就是方法重载。


103、方法的参数是基本类型的时候：形式参数的改变不影响实际参数。
     方法的参数是引用类型的时候（例如数组）：形式参数的改变影响实际参数。
     原因：基本类型的参数在栈中，用完就被垃圾回收了；引用类型的参数在堆中，用完之后不会马上被回收。


104、数组反转：
              public static void reverse(int[] arr) {
		for(int startIndex=0,endIndex=arr.length-1;startIndex<=endIndex;startIndex++,endIndex--) {
			int temp = arr[startIndex];
			arr[startIndex] = arr[endIndex];
			arr[endIndex] = temp;
		}
	}
}


105、栈的里面是变量和方法，堆的里面是new出来的对象，方法区里面有常量池。


106、private关键字可以修饰成员(成员变量和成员方法)，被private修饰的成员只在本类中才能访问。


107、this关键字：
                A:this:代表所在类的对象引用：方法被哪个对象调用，this就代表那个对象。
                B:什么时候使用this：局部变量和成员变量重名。


108、构造方法的格式：
                    a:方法名与类名相同
                    b:没有返回值类型，连void都没有
                    c:没有具体的返回值（也就是可以有return;只要不加具体的返回值就行）
如果你提供了构造方法，系统将不再提供。
构造方法也是可以重载的,重载条件和普通方法相同（也就是方法名相同，参数的数量或者类型不同）。


109、StringBuilder:
                   StringBuilder:是一个可变的字符串。字符串缓冲区类。  
                   String和StringBuilder的区别：
	                                       String的内容是固定的
	                                       StringBuilder的内容是可变的

String的+=拼接字符串耗费内存原因:
                                 每次拼接都会产生新的字符串对象,而利用StringBuilder来拼接字符串自始至终用的都是同一个StringBuilder容器。


110、FileWriter向文件中写数据：
                //创建输出流对象
		FileWriter fw = new FileWriter("d:\\a.txt");
		/*
		 * 创建输出流对象做了哪些事情:
		 * 		A:调用系统资源创建了一个文件
		 * 		B:创建输出流对象
		 * 		C:把输出流对象指向文件
		 */
		
		//调用输出流对象的写数据的方法
		//写一个字符串数据
		fw.write("IO流你好");
		//数据没有直接写到文件，其实是写到了内存缓冲区
		fw.flush();
		
		//释放资源
		//通知系统释放和该文件相关的资源
		fw.close();

FileWriter的追加写入：
                     FileWriter fw = new FileWriter("c.txt",true); //表示追加写入，默认是false


111、FileReader读数据：
                       //创建输入流对象
//		FileReader fr = new FileReader("fr.txt");
		FileReader fr = new FileReader("FileWriterDemo.java");
		
		//调用输入流对象的读数据方法
		//int read():一次读取一个字符
		
		/*
		
		int ch = fr.read();
		System.out.println(ch);
		System.out.println((char)ch);
		
		//这是时候，我们发现代码的重复度很高，想用循环改进，但是不知道循环的结束条件是什么
		ch = fr.read();
		System.out.println(ch);
		
		ch = fr.read();
		System.out.println(ch);
		//通过测试，我们知道，如果读取数据的返回值是-1的时候，就说明没有数据了，这也是我们循环的结束条件
		*/
		
		int ch;
		//1:fr.read()
		//2:ch=fr.read()
		//3:ch != -1
		while((ch=fr.read())!=-1) {
			//System.out.println(ch);
			//System.out.println((char)ch);
			System.out.print((char)ch);
		}
		
		//释放资源
		fr.close();


112、缓冲流对象BufferedReader()特有的读取数据的方法：readLine()读取一行。传入FileReader做参数。


113、匿名对象：
              匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。例如：new Person();


114、面向对象的三大特性：继承，封装，多态


115、子类调用父类中成员方法的特点：
                                  当在程序中通过对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。


116、方法重写：
              子类方法覆盖（也就是重写）父类方法，必须要保证权限大于等于父类权限。


117、子类与父类出现重名的成员变量和成员方法时：
                                              当子父类中出现了同名成员变量时，在子类中若要访问父类中的成员变量，必须使用关键字super来完成。


118、在每次创建子类对象时，父类的class文件也会进入内存中。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。
     子类的每个构造方法中均有默认的super(),调用父类的空参构造。手动调用父类构造会覆盖默认的super();

=======================================================================================================================================================================================
119、抽象方法和抽象类：
                      分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么                      此方法就是一个抽象方法。
    定义了抽象函数的类也必须被abstract关键字修饰（也就是有抽象方法的类必然是抽象类），被abstract关键字修饰的类是抽象类。

抽象方法定义的格式：
public abstract 返回值类型 方法名(参数);
抽象类定义的格式：
abstract class 类名 {
}

抽象类无法直接创建对象，只能被子类继承后，创建子类对象。
子类需要继承抽象父类并完成最终的方法实现细节(即重写方法，完成方法体)。

抽象类一定是个父类，因为抽象类是不断抽取共性需求而来的。
抽象类中是可以不定义抽象方法的，此时仅仅是不让该类创建对象，用于某些特殊的设计需要。

======================================================================================================================================================================================

120、接口：
          ?接口中的方法均为公共访问（也就是public）的抽象方法
?          接口中无法定义普通的成员变量

1、接口中可以定义变量，但是变量必须有固定的修饰符修饰，public static final 所以接口中的变量也称之为常量，其值不能改变。后面我们会讲解static与final关键字
2、接口中可以定义方法，方法也有固定的修饰符，public abstract
3、接口不可以创建对象。
4、子类必须覆盖掉接口中所有的抽象方法后，子类才可以实例化。否则子类是一个抽象类。

=====================================================================================================================================================================================
121、抽象类和接口的区别:
?                     抽象类为部分方法提供实现,避免子类重复实现这些方法,提高代码重用性;接口只能包含抽象方法;
?                     一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承)
                       抽象类为继承体系中的共性内容,接口为继承体系中的扩展功能
======================================================================================================================================================================================

122、多态：
          最终多态体现为父类引用变量可以指向子类对象。
          在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。

父类引用指向子类对象就是多态的定义格式。同一个父类的方法会被不同的子类重写为各自的具体实现。在调用方法时，调用的为各个子类重写后的方法。
父类类型  变量名 = new 子类类型();
变量名.方法名();
此时，虽然该变量指向的是子类对象，但表现为一个父类的形态，可以调用一切父类的方法，子类特有的方法将不能调用。

========================================================================================================================================================================================
123、多态的存在意义(优点)为： 
                            配合继承与方法重写提高了代码的复用性与扩展性，如果没有方法重写，则多态同样没有意义。

     多态的弊端:
                 不能调用子类的特有方法。

向上转型就是多态，向下转型（也就是子类转换成父类）是需要强转的。

==========================================================================================================================================================================================
124、instanceof：java 中的instanceof 运算符是用来在运行时指出对象是否是特定类的一个实例。instanceof通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例。

===========================================================================================================================================================================================
125、static：
            static修饰的成员被多个对象共享。被static修饰的成员可以并且建议通过类名直接访问。也可以通过某个对象访到属于类的静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员。


126、静态代码块：
静态代码块是定义在成员位置，使用static修饰的代码块。
特点：
?  它优先于主方法执行、优先于构造代码块执行，当以任意形式第一次使用到该类时执行。
?  该类不管创建多少对象，静态代码块只执行一次。
    可用于给静态变量赋值，用来给类进行初始化。


127、final：
final的意思为最终，不可变。final是个修饰符，它可以用来修饰类，类的成员，以及局 部变量。
?final修饰类不可以被继承，但是可以继承其他类。
?final修饰的方法不可以被覆盖,但父类中没有被final修饰方法，子类覆盖后可以加final。
final修饰的变量称为常量，这些变量只能赋值一次。
引用类型的变量值为对象地址值，地址值不能更改，但是地址内的对象属性值可以修改。
?修饰成员变量，需要在创建对象前赋值，否则报错。(当没有显式赋值时，多个构造方法的均需要为其赋值。)



128、?import导包代码书写的位置：在声明包package后，定义所有类class前，使用导包import包名.包名.类名;


129、四种访问权限修饰符：
?要想仅能在本类中访问使用private修饰；
?要想本包中的类都可以访问不加修饰符即可（也就是其他包中的子类也不可以访问）；
?要想本包中的类与其他包中的子类可以访问使用protected修饰
?要想所有包中的所有类都可以访问使用public修饰。
?注意：如果类用public修饰，则类名必须与文件名相同。一个文件中只能有一个public修饰的类。


130、内部类：
?什么是内部类
将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类。其他类也称为外部类。
?什么时候使用内部类
在描述事物时，若一个事物内部还包含其他可能包含的事物，比如在描述汽车时，汽车中还包含这发动机，这时发动机就可以使用内部类来描述。
class 汽车 { //外部类
	class 发动机 { //内部类
}
}
?内部类的分类
内部类分为成员内部类与局部内部类。
我们定义内部类时，就是一个正常定义类的过程，同样包含各种修饰符、继承与实现关系等。在内部类中可以直接访问外部类的所有成员。
成员内部类，定义在外部类中的成员位置。与类中的成员变量相似，可通过外部类对象进行访问
?定义格式
class 外部类 { 
	修饰符 class 内部类 {
		//其他代码
}
}
?访问方式
外部类名.内部类名 变量名 = new 外部类名().new 内部类名();


131、匿名内部类：
最常用到的内部类就是匿名内部类，它是局部内部类的一种。
定义的匿名内部类有两个含义：
?临时定义某一指定类型的子类
?定义后即刻创建刚刚定义的这个子类的对象

格式：
new 父类或接口(){
	//进行方法重写
} 


132、异常：
在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。
异常的根类是Throwable，其下有两个子类：Error与Exception，平常所说的异常指Exception。
?严重错误Error，无法通过处理的错误
?编译时异常Exception，编译时无法编译通过。如日期格式化异常
?运行时异常RuntimeException，是Exception的子类，运行时可能会报错，可以不处理。如数学异常

?抛出异常（JDK已有定义的异常会自动抛出异常，自定义异常需要手动抛出）
抛出异常的方法：throw new 异常类名(参数);
throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。
区分抛出异常throw和声明异常throws

final关键字的作用：
有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。


133、多异常处理：
?多异常处理
捕获处理：
1.多个异常分别处理
	2.多个异常一次捕获多次处理
	3.多个异常一次捕获一次处理
声明抛出异常：
	声明上使用,一次声明多个异常	

?运行时异常被抛出可以不处理。即不捕获也不声明抛出
?如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集（也就是不能抛出父类没有的异常）
?父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出
?当多异常处理时，捕获处理，前边的类不能是后边类的父类（也就是从小到大捕获）
?在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。
方法中已经出现返回语句返回值A，再在finally中修改A值，则最终的返回值仍为修改前A的值。但在该方法中A的值已经被修改了。

?继承Exception（编译时异常），必须要throws声明，一声明就告知调用者进行捕获，一旦问题处理了调用者的程序会继续执行。
?继承RuntimeExcpetion（运行时异常）,不需要throws声明的，这时调用是不需要编写捕获代码的，因为调用根本就不知道有问题。一旦发生NoAgeException，调用者程序会停掉，并有jvm将信息显示到屏幕，让调用者看到问题，修正代码。

134、System类：
               System类不能手动创建对象，因为构造方法被private修饰，阻止外界创建对象。System类中的都是static方法，类名访问即可。在JDK中，有许多这样的类。


135、基本来类型包装类：
                       其中需要注意int对应的是Integer，char对应的Character，其他6个都是基本类型首字母大写即可。


136、parseXXX(String s);其中XXX表示基本类型，参数为可以转成基本类型的字符串（注意不是转换成包装类型）


137、正则表达式的两种用法：
代码演示：
	String qq = "604154942";
	String regex = "[1-9][0-9]{4,14}";
	booleanflag2 = qq.matches(regex);

代码演示：
String s = "18-22-40-65";
	String regex = "-";
	String[] result = s.split(regex);


138、正则表达式规则：
正则表达式中明确区分大小写字母。我们来学习语法规则。
正则表达式的语法规则：
字符：x
含义：代表的是字符x
例如：匹配规则为 "a"，那么需要匹配的字符串内容就是 ”a”

字符：\\
含义：代表的是斜线字符'\' 
例如：匹配规则为"\\" ，那么需要匹配的字符串内容就是 ”\”

字符：\t
含义：制表符
例如：匹配规则为"\\t" ，那么对应的效果就是产生一个制表符的空间

字符：\n
含义：换行符
例如：匹配规则为"\\n"，那么对应的效果就是换行,光标在原有位置的下一行

字符：\r
含义：回车符
例如：匹配规则为"\\r"，那么对应的效果就是回车后的效果,光标来到下一行行首

字符类：[abc]
含义：代表的是字符a、b 或 c
例如：匹配规则为"[abc]"，那么需要匹配的内容就是字符a，或者字符b，或字符c的一个

字符类：[^abc]
含义：代表的是除了 a、b 或 c以外的任何字符
例如：匹配规则为"[^abc]"，那么需要匹配的内容就是不是字符a，或者不是字符b，或不是字符c的任意一个字符

字符类：[a-zA-Z]
含义：代表的是a 到 z 或 A 到 Z，两头的字母包括在内
例如：匹配规则为"[a-zA-Z]"，那么需要匹配的是一个大写或者小写字母

字符类：[0-9]
含义：代表的是 0到9数字，两头的数字包括在内
例如：匹配规则为"[0-9]"，那么需要匹配的是一个数字

字符类：[a-zA-Z_0-9]
含义：代表的字母或者数字或者下划线(即单词字符)
例如：匹配规则为" [a-zA-Z_0-9] "，那么需要匹配的是一个字母或者是一个数字或一个下滑线

预定义字符类：.
含义：代表的是任何字符
例如：匹配规则为" . "，那么需要匹配的是一个任意字符。如果，就想使用 . 的话，使用匹配规则"\\."来实现

预定义字符类：\d
含义：代表的是 0到9数字，两头的数字包括在内，相当于[0-9]
例如：匹配规则为"\\d "，那么需要匹配的是一个数字

预定义字符类：\w
含义：代表的字母或者数字或者下划线(即单词字符)，相当于[a-zA-Z_0-9]
例如：匹配规则为"\\w "，，那么需要匹配的是一个字母或者是一个数字或一个下滑线

边界匹配器：^
含义：代表的是行的开头
例如：匹配规则为^[abc][0-9]$ ，那么需要匹配的内容从[abc]这个位置开始, 相当于左双引号

边界匹配器：$
含义：代表的是行的结尾
例如：匹配规则为^[abc][0-9]$ ，那么需要匹配的内容以[0-9]这个结束, 相当于右双引号

边界匹配器：\b
含义：代表的是单词边界
例如：匹配规则为"\\b[abc]\\b"，那么代表的是字母a或b或c的左右两边需要的是非单词字符([a-zA-Z_0-9])
		String regex = ".*\\b[abc]\\b.*";
		String str = "abc a bbc";
		booleanflag = str.matches(regex);

数量词：X?
含义：代表的是X出现一次或一次也没有
例如：匹配规则为"a?"，那么需要匹配的内容是一个字符a，或者一个a都没有

数量词：X*
含义：代表的是X出现零次或多次
例如：匹配规则为"a*"，那么需要匹配的内容是多个字符a，或者一个a都没有

数量词：X+
含义：代表的是X出现一次或多次
例如：匹配规则为"a+"，那么需要匹配的内容是多个字符a，或者一个a

数量词：X{n}
含义：代表的是X出现恰好 n 次
例如：匹配规则为"a{5}"，那么需要匹配的内容是5个字符a

数量词：X{n,}
含义：代表的是X出现至少 n 次
例如：匹配规则为"a{5, }"，那么需要匹配的内容是最少有5个字符a

数量词：X{n,m}
含义：代表的是X出现至少 n 次，但是不超过 m 次
例如：匹配规则为"a{5,8}"，那么需要匹配的内容是有5个字符a 到 8个字符a之间

逻辑运算符：XY
含义：代表的是X后跟Y
例如：匹配规则为"ab"，那么需要匹配的字符串内容就是 ”ab”

逻辑运算符：X|Y
含义：代表的是X 或 Y
例如：匹配规则为"a|b"，那么需要匹配的字符串内容就是 ”a”或”b”

逻辑运算符：(X)
含义：代表的是（）括号内的数据作为一组数据出现，(X)的方式称为正则表达式中的组


139、Collection集合：
Collection接口是集合中的顶层接口
?Collecton接口常用的子接口有：List接口、Set接口
?List接口常用的子类有：ArrayList类、LinkedList类
Set接口常用的子类有：HashSet类、LinkedHashSet类


140、Iterator迭代器：
迭代的常规用法中我们要尽量避免在迭代过程中为集合添加/删除数据。否则会报错，原因是Java抛出了并发修改异常。	
迭代过程中并发修改异常的原因为迭代器中”记忆”的集合长度与集合中实际长度不同，而导致出现索引与实际元素不符甚至无限循环的情况发生。
所以在使用Iterator时，避免类似操作，for循环底层为迭代器实现，所以也需要避免类似操作。

java中提供了很多个集合，它们在存储元素时，采用的存储方式不同。我们要取出这些集合中的元素，可通过一种通用的获取方式来完成。
增强for循环是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。（和普通for循环一样）

增强for循环和老式的for循环有什么区别？
注意：新for循环必须有被遍历的目标。目标只能是Collection或者是数组。
建议：遍历数组时，如果仅为遍历，可以使用增强for如果要对数组的元素进行 操作，使用老式for循环可以通过角标操作。


141、泛型：
使用泛型的好处：
?将运行时期的ClassCastException，转移到了编译时期变成了编译失败。
?避免了类型强转的麻烦。

含有泛型的类：修饰符 class 类名<代表泛型的变量> {  }
含有泛型的方法：
定义格式：修饰符 <代表泛型的变量> 返回值类型 方法名(参数){  }（分为参数中有泛型和返回值中有泛型）
例如，
Public class GenericMethod <E>{
	
	Public void show(E e){
		System.out.println(e);
	}


含有泛型的接口：
	定义格式：修饰符 interface接口名<代表泛型的变量> {  }
?例如，
Public interface Inter <E>{
	Public abstractvoid show(E e);
}


142、数据存储的常用结构有：堆栈、队列、数组、链表。


143、set集合：
             查阅Set集合的API介绍，通过元素的equals方法，来判断是否为重复元素，它是个不包含重复元素的集合。Set集合取出元素的方式可以采用：迭代器、增强for。


144、HashSet：
查阅HashSet集合的API介绍：此类实现Set接口，由哈希表支持（实际上是一个 HashMap集合）。HashSet集合不能保证的迭代顺序与元素存储顺序相同。
HashSet集合，采用哈希表结构存储数据，保证元素唯一性的方式依赖于：hashCode()与equals()方法。

2.2HashSet集合存储数据的结构（哈希表）
什么是哈希表呢？
哈希表底层使用的也是数组机制，数组中也存放对象，而这些对象往数组中存放时的位置比较特殊，当需要把这些对象给数组中存放时，那么会根据这些对象的特有数据结合相应的算法，计算出这个对象在数组中的位置，然后把这个对象存放在数组中。而这样的数组就称为哈希数组，即就是哈希表。
当向哈希表中存放元素时，需要根据元素的特有数据结合相应的算法，这个算法其实就是Object类中的hashCode方法。由于任何对象都是Object类的子类，所以任何对象有拥有这个方法。即就是在给哈希表中存放对象时，会调用对象的hashCode方法，算出对象在表中的存放位置，这里需要注意，如果两个对象hashCode方法算出结果一样，这样现象称为哈希冲突，这时会调用对象的equals方法，比较这两个对象是不是同一个对象，如果equals方法返回的是true，那么就不会把第二个对象存放在哈希表中，如果返回的是false，就会把这个值存放在哈希表中。
总结：保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。

给HashSet中存储JavaAPI中提供的类型元素时，不需要重写元素的hashCode和equals方法，因为这两个方法，在JavaAPI的每个类中已经重写完毕，如String类、Integer类等。

3.1ArrayList的contains方法判断元素是否重复原理：
当ArrayList存放自定义类型时，由于自定义类型在未重写equals方法前，判断是否重复的依据是地址值，所以如果想根据内容判断是否为重复元素（contains()方法），需要重写元素的equals方法。


145、Map集合遍历键找值方式：
//创建Map对象
		Map<String, String> map = new HashMap<String,String>();
		//给map中添加元素
		map.put("邓超", "孙俪");
		map.put("李晨", "范冰冰");
map.put("刘德华", "柳岩");
		//获取Map中的所有key
		Set<String> keySet = map.keySet();
		//遍历存放所有key的Set集合
		Iterator<String> it =keySet.iterator();
		while(it.hasNext()){
			//得到每一个key
			String key = it.next();
			//通过key获取对应的value
			String value = map.get(key);
			System.out.println(key+"="+value);
		}

第二种遍历方式：
//创建Map对象
		Map<String, String> map = new HashMap<String,String>();
		//给map中添加元素
		map.put("邓超", "孙俪");
		map.put("李晨", "范冰冰");
map.put("刘德华", "柳岩");
		//获取Map中的所有key与value的对应关系
		Set<Map.Entry<String,String>> entrySet = map.entrySet();
		//遍历Set集合
		Iterator<Map.Entry<String,String>> it =entrySet.iterator();
		while(it.hasNext()){
			//得到每一对对应关系
			Map.Entry<String,String> entry = it.next();
			//通过每一对对应关系获取对应的key
			String key = entry.getKey();
			//通过每一对对应关系获取对应的value
			String value = entry.getValue();
			System.out.println(key+"="+value);
		}

注意：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。


146、LinkedHashMap：
?如果要保证map中存放的key和取出的顺序一致，可以使用LinkedHashMap集合来存放。
我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？
在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。


147、可变参数：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。


148、Collections集合工具类（注意下面的方法没有返回值）：
public static <T> void sort(List<T> list) // 集合元素排序
?public static void shuffle(List<?> list) //  集合元素存储位置打乱


149、File对象：
//File构造函数演示
		String pathName = "e:\\java_code\\day22e\\hello.java";
		File f1 = new File(pathName);//将Test22文件封装成File对象。注意；有可以封装不存在文件或者文件夹，变成对象。


150、获取文件名称和文件对象：
public class FileMethodDemo3 {
	public static void main(String[] args) {
		File dir = new File("e:\\java_code");
		//获取的是目录下的当前的文件以及文件夹的名称。
		String[] names = dir.list();
		for(String name : names){
			System.out.println(name);
		}
		//获取目录下当前文件以及文件对象，只要拿到了文件对象，那么就可以获取其中想要的信息
		File[] files = dir.listFiles();
		for(File file : files){
			System.out.println(file);
		}
	}
}

注意：在获取指定目录下的文件或者文件夹时必须满足下面两个条件
1，指定的目录必须是存在的，
2，指定的必须是目录。否则容易引发返回数组为null，出现NullPointerException


151、递归
递归，指在当前方法内调用自己的这种现象
public void method(){
	System.out.println(“递归的演示”);
	//在当前方法内调用自己
	method();
}
递归分为两种，直接递归和间接递归。
直接递归称为方法自身调用自己。间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。
?递归的代码演示，计算1-n之间的和，使用递归完成
public class DiGuiDemo {
	public static void main(String[] args) {
		//计算1~num的和，使用递归完成
		int n = 5;
		int sum = getSum(n);
		System.out.println(sum);
		
	}
        //外层定义方法，里层调用方法
	public static int getSum(int n) {
		if(n == 1){
			return 1;
		}
		return n + getSum(n-1);
	}
}

注意：递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。
在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。（看来方法是在栈里）


152、写入文件和读取文件：
public class FileOutputStreamDemo2 {
	public static void main(String[] args) throws Exception {
		File file = new File("c:\\file.txt");
		FileOutputStream fos = new FileOutputStream(file, true);
		String str = "\r\n"+"itcast";
		fos.write(str.getBytes());
		fos.close();
	}
}

public class FileInputStreamDemo {
	public static void main(String[] args) throws IOException {
		File file = new File("c:\\file.txt");
		//创建一个字节输入流对象,必须明确数据源，其实就是创建字节读取流和数据源相关联。
		FileInputStream fis = new FileInputStream(file);
		//读取数据。使用 read();一次读一个字节。
		int ch = 0;
		while((ch=fis.read())!=-1){
			System.out.println("ch="+(char)ch);
		}
		// 关闭资源。
		fis.close();
	}
}


153、序列化：
Serializable标记接口。该接口给需要序列化的类，提供了一个序列版本号。serialVersionUID. 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。

瞬态关键字transient
当一个类的对象需要被序列化时，某些属性不需要被序列化，这时不需要序列化的属性可以使用关键字transient修饰。只要被transient修饰了，序列化时这个属性就不会被序列化了。
同时静态修饰也不会被序列化，因为序列化是把对象数据进行持久化存储，而静态的属于类加载时的数据（也就是并不属于具体对象，而是属于类），不会被序列化。


154、打印流：
打印流根据流的分类：
?字节打印流	PrintStream
?字符打印流	PrintWriter
?方法：
void print(String str): 输出任意类型的数据，
void println(String str): 输出任意类型的数据，自动写入换行操作
?代码演示：
 /* 
 * 需求：把指定的数据，写入到printFile.txt文件中
 * 
 * 分析：
 * 	1，创建流
 * 	2，写数据
 * 	3，关闭流
 */
public class PrintWriterDemo {
	public static void main(String[] args) throws IOException {
		//创建流
		//PrintWriter out = new PrintWriter(new FileWriter("printFile.txt"));
		PrintWriter out = new PrintWriter("printFile.txt");
		//2，写数据
		for (int i=0; i<5; i++) {
			out.println("helloWorld");
		}
		//3,关闭流
		out.close();
	}
}


155、多线程：
一个程序运行后至少有一个进程，一个进程中可以包含多个线程


156、线程运行的原理：

?分时调度：
所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。
?抢占式调度：
优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。

其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。


157、
创建新执行线程有两种方法：
?一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。创建对象，开启线程。run方法相当于其他线程的main方法。
另一种方法是声明一个实现 Runnable 接口的类。该类然后实现 run 方法。然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。

158、创建线程的第一种方式：

创建线程方式一继承Thread类
创建线程的步骤：
1 定义一个类继承Thread。
2 重写run方法。
3 创建子类对象，就是创建线程对象。
4 调用start方法，开启线程并让线程执行，同时还会告诉jvm去调用run方法。
?测试类
public class Demo01 {
	public static void main(String[] args) {
		//创建自定义线程对象
		MyThread mt = new MyThread("新的线程！");
		//开启新线程
		mt.start();
		//在主方法中执行for循环
		for (int i = 0; i < 10; i++) {
			System.out.println("main线程！"+i);
		}
	}
}
?自定义线程类
public class MyThread extends Thread {
	//定义指定线程名称的构造方法
	public MyThread(String name) {
		//调用父类的String参数的构造方法，指定线程的名称
		super(name);
	}
	/**
	 * 重写run方法，完成该线程执行的逻辑
	 */
	@Override
	public void run() {
		for (int i = 0; i < 10; i++) {
			System.out.println(getName()+"：正在执行！"+i);
		}
	}
}

思考：线程对象调用 run方法和调用start方法区别？
线程对象调用run方法不开启线程，仅是对象调用方法。线程对象调用start开启线程，并让jvm调用run方法在开启的线程中执行。
继承Thread类原理
我们为什么要继承Thread类，并调用其的start方法才能开启线程呢？
继承Thread类：因为Thread类用来描述线程，具备线程应该有功能。那为什么不直接创建Thread类的对象呢？如下代码：
Thread t1 = new Thread();
t1.start();//这样做没有错，但是该start调用的是Thread类中的run方法，而这个run方法没有做什么事情，更重要的是这个run方法中并没有定义我们需要让线程执行的代码。

多线程执行时，到底在内存中是如何运行的呢？
以上个程序为例，进行图解说明：
多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。
当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。

?Thread.currentThread()获取当前线程对象
Thread.currentThread().getName();获取当前线程对象的名称

通过结果观察，原来主线程的名称：main；自定义的线程：Thread-0，线程多个时，数字顺延。如Thread-1......
进行多线程编程时，不要忘记了Java程序运行是从主线程开始，main方法就是主线程的线程执行内容。


159、创建线程的第二种方式：

创建线程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。
创建线程的步骤。
1、定义类实现Runnable接口。
2、覆盖接口中的run方法。。
3、创建Thread类的对象
4、将Runnable接口的子类对象作为参数传递给Thread类的构造函数。
5、调用Thread类的start方法开启线程。
?代码演示：
public class Demo02 {
	public static void main(String[] args) {
		//创建线程执行目标类对象
		Runnable runn = new MyRunnable();
		//将Runnable接口的子类对象作为参数传递给Thread类的构造函数
		Thread thread = new Thread(runn);
		Thread thread2 = new Thread(runn);
		//开启线程
		thread.start();
		thread2.start();
		for (int i = 0; i < 10; i++) {
			System.out.println("main线程：正在执行！"+i);
		}
	}
}
?自定义线程执行任务类
public class MyRunnable implements Runnable{

	//定义线程要执行的run方法逻辑
	@Override
	public void run() {
		
		for (int i = 0; i < 10; i++) {
			System.out.println("我的线程：正在执行！"+i);
		}
	}
}

为什么需要定一个类去实现Runnable接口呢？继承Thread类和实现Runnable接口有啥区别呢？
实现Runnable接口，避免了继承Thread类的单继承局限性。覆盖Runnable接口中的run方法，将线程任务代码定义到run方法中。

160、匿名内部类的方式创建线程：

使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。
?方式1：创建线程对象时，直接重写Thread类中的run方法
		new Thread() {
			public void run() {
				for (int x = 0; x < 40; x++) {
					System.out.println(Thread.currentThread().getName()
							+ "...X...." + x);
				}
			}
		}.start();

?方式2：使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法
		Runnable r = new Runnable() {
			public void run() {
				for (int x = 0; x < 40; x++) {
					System.out.println(Thread.currentThread().getName()
							+ "...Y...." + x);
				}
			}
		};
		new Thread(r).start();


161、Runnable比Thread创建线程的优点：

java不允许多继承，因此实现了Runnable接口的类可以再继承其他类。
Runnable就相当于一个作业，而Thread才是真正的处理线程，我们需要的只是定义这个作业，然后将作业交给线程去处理，这样就达到了松耦合，也符合面向对象里面组合的使用，另外也节省了函数开销，继承Thread的同时，不仅拥有了作业的方法run()，还继承了其他所有的方法。也体现了面向对象的三大特性中的封装特性，体现了面向对象的设计思想。


162、线程安全问题产生的原因：
其实，线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

产生多线程问题的例子：

需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟
?测试类
public class ThreadDemo {
	public static void main(String[] args) {
		//创建票对象
		Ticket ticket = new Ticket();
		
		//创建3个窗口
		Thread t1  = new Thread(ticket, "窗口1");
		Thread t2  = new Thread(ticket, "窗口2");
		Thread t3  = new Thread(ticket, "窗口3");
		
		t1.start();
		t2.start();
		t3.start();
	}
}
?模拟票
public class Ticket implements Runnable {
	//共100票
	int ticket = 100;

	@Override
	public void run() {
		//模拟卖票
		while(true){
			if (ticket > 0) {
				//模拟选坐的操作
				try {
					Thread.sleep(1);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(Thread.currentThread().getName() + "正在卖票:" + ticket--);
			}
		}
	}

解决方法：Synchronized同步方法和同步代码块。前者的锁是this对象，后者的锁是自己定义的对象。静态同步方法中的锁对象是 类名.class。


163、Lock接口解决多线程安全问题：
查阅API，查阅Lock接口描述，Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。
我们使用Lock接口，以及其中的lock()方法和unlock()方法替代同步，对电影院卖票案例中Ticket类进行如下代码修改：
public class Ticket implements Runnable {
	//共100票
	int ticket = 100;
	
	//创建Lock锁对象
	Lock ck = new ReentrantLock();
	
	@Override
	public void run() {
		//模拟卖票
		while(true){
			//synchronized (lock){
			ck.lock();
				if (ticket > 0) {
					//模拟选坐的操作
					try {
						Thread.sleep(10);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					System.out.println(Thread.currentThread().getName() + "正在卖票:" + ticket--);
				}
			ck.unlock();
			//}
		}
	}
}


164、线程的状态：
等待和休眠不能进入阻塞态，但是反之可以。休眠sleep()传入时间参数，到时候自己唤醒；等待需要手动唤醒。等待不释放锁，休眠释放锁。


165、TCP/IP协议：
TCP/IP协议中的四层分别是应用层、传输层（tcp）、网络层(ip)和链路层，每层分别负责不同的通信功能。


166、注解：
?什么是注解：Annotation注解，是一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次
?对比注释：注释是给开发人员阅读的，注解是给计算机提供相应信息的。
?注解的作用：
1.编译检查：通过代码里标识注解，让编译器能够实现基本的编译检查。例如：@Override
2.编写文档：通过代码里标识注解，辅助生成帮助文档对应的内容，@Document


167、反射的具体内容参见就业班第15天笔记。反射的定义：获取类的class对象，进而通过class对象获取类的一切。


168、类加载器：?

类加载器：类加载器是负责加载类的对象。将class文件（硬盘）加载到内存生成Class对象。
所有的类加载器都是  java.lang.ClassLoader 的子类
类.class.getClassLoader() 获得加载自己的类加载器
采用全盘负责委托机制保证一个class文件只会被加载一次，形成一个Class对象。

类加载器的三个组成部分：
Bootstrap ClassLoader根类加载器：负责java核心类的加载。
Extension ClassLoader扩展类加载器：负责JRE的扩展目录中jar包的加载。
System ClassLoader系统类加载器：负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包的类路径。


169、动态代理：

java代理有jdk动态代理、cglib代理，这里只说下jdk动态代理，jdk动态代理主要使用的是java反射机制（既java.lang.reflect包）

原理是（歌手、经纪人做例子）：
?建立一个公共的接口，比如：歌手public interface Singer；
?用具体的类实现接口，比如：周杰伦，他是歌手所以实现Singer这个接口，class MySinger implements Singer,重写singer方法.
?建立代理类，这里也就是经纪人，他需要实现InvocationHandler接口，并重写invoke方法
?这样当有什么事情，要找周杰伦（具体类）唱歌的时候，就必须先到经纪人（代理类）那里处理，代理人在决定要不要与你见面（该方法要不要执行）,找到经纪人方法invoke,经纪人方法invoke来找周杰伦的singer方法

170、Schema约束：
什么是Schema
Schema是新的XML文档约束；
Schema要比DTD强大很多，是DTD 替代者；
Schema本身也是XML文档，但Schema文档的扩展名为xsd，而不是xml。
Schema 功能更强大，数据类型更完善
Schema 支持名称空间

声明命名空间
默认命名空间：<xxx xmlns=””>，使用<标签>
显式命名空间：<xxx xmlns:别名=””>，使用<别名:标签>


171、数据库

在价格排序(降序)的基础上，以分类排序(降序)
SELECT * FROM product ORDER BY price DESC,category_id DESC;


?having与where的区别:
?having是在分组后对数据进行过滤.
where是在分组前对数据进行过滤

统计各个分类商品的个数,且只显示个数大于1的信息：
SELECT category_id ,COUNT(*) FROM product GROUP BY category_id HAVING COUNT(*) > 1;

172、sql注入问题的解决方法：我们使用PreparedStatement来解决对应的问题。
PreparedStatement预处理对象，处理的每条sql语句中所有的实际参数，都必须使用占位符?替换。
String sql = "select * from user where username = ? and password = ?";
	PreparedStatement使用，需要通过以下3步骤完成：
1.PreparedStatement预处理对象代码：
#获得预处理对象，需要提供已经使用占位符处理后的SQL语句
PreparedStatement psmt = conn.prepareStatement(sql)
2.设置实际参数
void setXxx(int index, Xxx xx) 将指定参数设置指定类型的值
	参数1：index 实际参数序列号，从1开始。
	参数2：xxx 实际参数值，xxx表示具体的类型。
例如：
setString(2, "1234") 把SQL语句中第2个位置的占位符?替换成实际参数 "1234"
3.执行SQL语句:
int executeUpdate(); --执行insert update delete语句.
ResultSet executeQuery(); --执行select语句.
boolean execute(); --执行select返回true 执行其他的语句返回false.


173、jdbc原理：
Java提供访问数据库规范称为JDBC，而生产厂商提供规范的实现类称为驱动。JDBC是接口，驱动是接口的实现。


175、jdbc编程步骤：

1.注册驱动.
2.获得连接.
3.获得语句执行平台
4.执行sql语句
5.处理结果
6.释放资源.

//1 注册驱动
	Class.forName("com.mysql.jdbc.Driver");
	
	//2 获得连接
	String url = "jdbc:mysql://localhost:3306/mydb";
	Connection conn = DriverManager.getConnection(url, "root", "root");
	
	//3获得语句执行者
	Statement st = conn.createStatement();
	
	//4执行SQL语句
	ResultSet rs = st.executeQuery("select * from category");
	
	//5处理结果集
	while(rs.next()){
		// 获得一行数据
		
		Integer cid = rs.getInt("cid");
		String cname = rs.getString("cname");
		
		System.out.println(cid + " , " + cname);
	}
	//6释放资源
	rs.close();
	st.close();
	conn.close();


176、事务：
事务是指逻辑上的一组操作;要么全部成功,要么全部失败;
作用:保证数据的安全性和完整性!


177、事务的特性：

原子性;(事务内的操作是一个整体,不可分割);
一致性;(在事务开启之后,到事务提交之前,应该保证事务的操作不能改变);
隔离性;(一个事务在执行期间不能受到其他事务的干扰)
持久性;(事务一旦结束,结果就不能再次改变);


178、数据库隔离级别:
1 read uncommitted	:读未提交.脏读，不可重复读，虚读/幻读都可能发生.
2 read committed	:读已提交.避免脏读.但是不可重复读和虚读/幻读有可能发生.（Oracle默认）
4 repeatable read	:可重复读.避免脏读,不可重复读.但是虚读/幻读有可能发生.（MySql默认）
8 serializable		:串行化，可解决所有问题（也就是没有任何问题）

脏读：还没有提交的就被读取了
不可重复读：在读取的过程中另一个线程修改了数据，导致两次读到的不一样
虚读/幻读：在读取的过程中另一个线程增加/减少了数据，导致两次读到的数据条数不一样

179、三层架构表现层，业务层，持久层的好处：
1:高内聚
2:低耦合
3:可维护
4:可重用
5:可扩展


180、ThreadLocal:
当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。


181、http请求包括：请求行，请求头，请求体
     http响应包括：响应行，响应头，响应体


182、Servlet生命周期：
用户第一次访问Servlet时创建Servlet的实例并执行init()方法，移除项目或者关闭服务器的时候销毁Servlet。
get方法的话就会访问doGet()，post方法的话就会访问doPost()。
每次请求服务器都会创建一个新的线程访问service()方法。


183、Cookie能保存中文吗？
     回答是：不能！但是可以对中文数据进行处理之后进行保存！


184、Session：
             Session如何销毁呢？
		方式一：invalidate();
		方式二：服务器非正常关闭【正常关闭，session依旧存在，服务器在正常关闭的时候会将session进行序列化到本地磁盘，下次启动会将磁盘的数据反序列化到内存中去】
		方式三：让它超时(默认存活30分钟)

session在访问tomcat服务器HttpServletRequest的getSession(true)的时候创建，tomcat的ManagerBase类提供创建sessionid的方法：随机数+时间+jvmid；

存储在服务器的内存中，tomcat的StandardManager类将session存储在内存中，也可以持久化到file，数据库，memcache，redis等。客户端只保存sessionid到cookie中，而不会保存session，session销毁只能通过invalidate或超时，关掉浏览器并不会关闭session。


185、Cookie：

Cookie的生命
	Cookie的默认生命是一个会话级别的(关闭浏览器就没了)
		设置Cookie的生命让其存活的时间更持久
			setMaxAge(int s);//设置 cookie 的最大生存时间，以秒为单位。
		追杀cookie
			setMaxAge(0);

Cookie的规范(你只需要知道一点：cookie的大小和个数是有限制的)
	Cookie的规范是一个组织指定！
		单个的Cookie的大小不超过4KB;
		一个服务器最多可以向客户端浏览器保存20个cookie
		一个客户端浏览器最多保存300个Cookie

	但是在浏览器大战的今天，一些浏览器厂商为了抢夺客户，对cookie进行了扩容(也是有限度的)，比如 8KB,100，500

Cookie的路径
	cookie的路径只与是否归还(归还的路径)有关，不能按照常规的路径去理解！！！
		归还的路径：目前指的就是创建这个cookie的路径(cookie的默认路径就是当前创建这个cookie所在的Servlet的路径：端口之后servlet名称之前的这么一段)（端口之后就是项目名）
	
		案例中：
			Servlet的路径是：/day37_Cookie_64
			cookie的路径是：/day37_Cookie_64
			
			后面你访问的路径如何包含了之前cookie的路径，那么就会将这个cookie携带过去！否则携带不过去*****************************
			http://localhost:8080/day37_Cookie_64/LastVisitTimeServlet


186、jsp注释：
?JSP注释、Java注释、HTML注释对比：
<%-- jsp注释--%>
<%	//java注释	%>
<!-- html注释-->

（不管是什么注释都是写在jsp里面，所以源码阶段可见其实是废话）
Jsp注释：源码阶段可见、java文件中不可见、html源码不可见
Java注释：源码阶段可见、java文件中可见、html源码不可见（注释方法比较奇怪）
Html注释：源码阶段可见、java文件中可见、html源码可见

脚本：(嵌套java代码片段、输出、声明)
		嵌套java代码片段：<% java代码 %>    	等价于类中的方法(方法里面可以写啥，这个脚本中就可以写啥！)
		输出：<%= %>  注意：%与=中间不能有空格	等价于response.getWriter().write();
		声明：<%！ %>						等价于类(类中能写啥，这个脚本中就能写啥！)



187、jsp的四个域范围：
?page：表示当前页，通常没用。jsp标签底层使用。
?request：表示一次请求。通常一次请求就一个页面，但如果使用请求转发，可以涉及多个页面。
?session：表示一次会话。可以在多次请求之间共享数据。（一次会话指的是从第一次访问页面到关闭浏览器，因为关闭浏览器之后保存在cookie之中的sessionId就没了。当然，可以设置cookie有效时间）
?application：表示 一个web应用(项目)。可以整个web项目共享，多次会话共享数据。有效期和Servlet生命一样长，直到关闭服务器或移除项目保存的信息才会消失。


188、JSTL介绍
我们说EL是获取数据，说白了就是等价于<%= %>,jstl它是取代<%  %>的！但是一直没有全部替换掉。愿景！
jstl需要taglib指令。

189、三层架构与mvc区别：

M:model 模型 由javabean负责(负责数据的流转)
V:view 视图 由JSP负责(将Javabean里面的数据显示给用户看)
C:controller 控制器 由servlet负责(接收处理响应，一些操作的流程走向)

JavaEE三层结构分别是WEB层、业务逻辑层、数据访问层。而MVC主要解决WEB层的技术！


190、Filter：
?          过滤器是一个运行在服务器端，先于与之相关的Servlet或者Jsp页面之前运行，对请求资源进行过滤功能的技术。它是JavaWEB三大组件(Servlet、Filter、 Listener)之一！

?过滤器的编写流程
第一步：编写一个类实现javax.servlet.Filter接口（配置文件拦截之后进入该类中的方法，满足某些逻辑之后就用chain.doFilter(request,response);语句放行）
第二步：在web.xml中配置<filer>和<filter-mapping>配置项【快速创建方式不需要】


191、
什么是装设者设计模式呢？
			设计模式：指的是对某一类问题提出的一套解决方案！(单例设计模式：一个类只允许创建一个实例对象)
			装饰者设计模式：专门解决对方法近增强的这一类问题！
				所有的设计模式都有固定的格式：
					动态代理：	
						第一步：创建一个被代理对象
						第二步：创建一个代理对象（在代理对象中的invoke方法中对指定的方法进行增强）

					装饰者设计模式：
						1.自己编写的类(MyHttpServletRequest)与要增强的类或者接口()要有共同的接口(HttpServletRequest)
						2.在自己编写的类(MyHttpServletRequest)的构造方法中要有已知实现类(需要增强的这个类)的一个引用
						3.在自己编写的类(MyHttpServletRequest)要有成员私有变量来存储已知实现类(目的是为了在自己编写的这个类中实现共同接口方法的时候直接调用已知实现类的方法)
						4.对指定的方法进行增强(getParameter)
						5.对其它方法(后续需要使用的方法)进行实现

chain.doFilter(request,response);语句用来放行过滤器（也就是通过了过滤器，没有被拦截）



192、Listener监听器：
所谓的监听器是指对整个WEB环境的监听,当被监视的对象(事件源)发生改变时，立即调用相应的方法进行处理。(被监视的对象什么时候发生改变？调用什么方法？)
	域对象本身：创建和销毁
	域对象属性：域对象属性的变更(添加、替换、删除)
	JavaBean：你将这个JavaBean保存session,替换，移除


193、Ajax

1.使用同步方式来完成注册表单用户名后台校验
		使用这种方式实现，我们发现，一旦用户注册的时候，输入的用户名被占用了，那么下面所有的输入项内容都没了，如果多操作几次，还是这个样子，会导致用户流失！
		这种会将整个页面进刷新的效果，对于用户而言，体验效果是特别差的！我们得解决这个问题！可以使用异步的方式(Ajax方式)！！！
		
	2.Ajax的介绍
		Ajax指的是：异步的javascript和xml！在不刷新整个页面的前提下，对局部的页面内容进行刷新！里面使用的都是老技术(很早出现的)，新思想！！！它可以使得页面不再进行全部刷新，而是局部内容刷新！
			javascript是核心，xml是传递数据的格式(现在几乎不用了！使用json数据格式来替换)
		
		同步方式：将数据保存到域对象！页面跳转(在页面从域对象中获取)
		异步方式：直接通过响应体将数据响应到客户端浏览器
		
	3.Ajax的操作
		语法：$.post(url,data,callback,type);  【重点掌握】
			url:发送请求的地址(指向一个Servlet)
			data:请求参数(使用json数据格式，例如：{"color":"red","background-color":"black"})
			callback：回调函数(当服务器端servlet没有异常,即响应状态码为200的时候才会值执行)
			tyep:整个数据传输使用的格式(text,json)(注意是服务器返回数据的数据格式，而不是浏览器发送请求的数据格式)
	
		例如：$.post("${pageContext.request.contextPath}/RegisterServlet",{"username":"jack"},function(data){
				//当服务器端响应的状态码为200的时候，这个里面的代码就会执行！
				//data：代表的是从服务器端响应过来的数据！
			});

	4.$.get()方法
		除了请求方式与处理乱码的方式与post不一样以外，操作一模一样！
		语法：$.get(url,data,callback,type);
			url：请求的路径(指向一个servlet)
			data:请求参数(使用json数据格式，例如：{"username":"jack"})
			callback:回调函数(只有服务器响应状态码为200的时候，它会才执行)
			type:传输的数据格式
		
		开发中，优先考虑使用$.post();方法

	5.$().load()方法  【了解】
		智能的Ajax的方式，开发中不用！！！它对指定的元素进行操作！
		
		load方法：如果有参数，就是post请求；没有错参数，就是get请求
			$("#div1").load(url,data,function(data){
				//回调函数要想执行，服务器端响应状态码必须是200！
			});
			改写：
			$.post(url,data,function(data){
				$("#div1").html(data);
			});

	6.$.ajax()方法 【重点掌握！！！！】
		它是功能最强大的一个ajax的方法！也是开中中最常用的一个！！！！
		语法:
			$.ajax({
				type:"get",//请求方式
				url:"${pageContext.request.contextPath}/RegisterServlet",//请求路径
				data:{"username":"jack"},//请求参数
				success:function(data){
					//服务器响应状态码为200执行的内容
					//data:服务器端响应的数据
				},
				error:function(XMLHttpRequest, textStatus, errorThrown){
					//服务器端出现异常(状态码为4xx，5xx)执行的代码
					//XMLHttpRequest：ajax的核心引擎对象！
					//textStatus：错误信息(出现问题，错误信息在这个参数中，值可能为：null,error,notmodifed,timeout,parsererror)
					//errorThrown：捕获的异常对象
				}
			});

		使用之前的$.post或者$.get的方法，都可以使用$.ajax进行改写！！！！

	7.Ajax的执行原理
		之前使用的都是jQuery的Ajax方式，除了操作比传统的要简便，最重要的一点，它们都解决了浏览器兼容问题！


	8.同步与异步的区别
		同步：
			1.将数据保存到域对象，然后页面跳转进行操作
			2.整体刷新(整个页面都刷新，用户体验差)
			3.发送一次请求，如果没有得到响应，那么是无法进行其它的操作(再次发送另外的请求！)
			
		异步：
			1.直接通过响应体(response.getWriter.write())来操作的！
			2.局部刷新(用户体验良好)
			3.发送一个请求，不管有没有响应，都可以进行其它的操作(同时发送多个不同的请求)

	9.请求方式返回数据格式type
		type：从服务器端响应过来数据的格式，默认的是text,使用最多的是json数据格式
		如果是json数据格式，处理乱码就会发生改变：
		以前：【同步】
			response.setContentType("text/html;charset=utf-8");
		现在：【异步】
			response.setContentType("application/json;charset=utf-8");

		关于json数据格式：
			一个严格的json数据，其key和value都必须带上引号！如果value它是一个变量，引号不用写！实际开发，发送数据给的json,key的引号可以省略不写；响应的数据key都是有引号的！
			json是一种轻量级的数据交换格式。JSON采用完全独立于语言的文本格式，就是说不同的编程语言JSON数据是一致的。(它不是java特有的！)它的传输效率特别高(比xml高！)
		例如：一个json数据：
			{"key1":"value1","key2":"value2","key3":"value3","key4":"value4"……}

		开发中，如果做一个查询，一般得到的都是一个Java对象或者对象集合！而响应数据都会使用json数据格式，那么如何将对象或者对象的集合转成json数据格式呢？【使用工具！】
		
		一旦转换了，我们就得到了一个字符串的json数据了，关键问题是，我们怎么获得json字符串中的数据呢？
		
	10.获得json中的数据
		//1.json对象
		var city = {
			"name":"北京",	
			"desc":"帝都"
		}
		//获得描述信息:帝都
		alert(city.desc);
		alert(city["desc"]);
		
		//2.json数组
		var province = ["河南","浙江","江苏","四川"];
		//获得省份:四川
		alert(province[3]);
		
		//3.复杂的json数据（数组里面包含json）
		var pc = [{
			"cityName":"信阳",
			"cityDesc":"毛尖"
		},{
			"name":"勇哥",
			"desc":"皮革厂"
		},{
			"sex":"FatBoy",
			"hobby":"抽烟"
		}];
		//获得数据：抽烟
		alert(pc[2].hobby);

	11.Java对象与json之间的转换
		JSON-LIB：需要导入相关的jar包(有6个)
			开发中:
				String json = JSONArray.fromObject(data).toString();//data:需要转的数据
				String json = JSONObject.fromObject(data).toString();//data:需要转的数据
			JSONArray：数组、list(list中有对象！)  （单列）
			JSONObject：对象！Map  （双列）


194、Linux常用命令：
ll(显示当前文件夹内的文件的详细信息),ls(显示当前文件夹内的文件信息)vim,pwd,cd,rm ,cat(文件较小时查看文件内容),mv,find(查看指定名称的文件所在的目录),zxvf,zcvf,ifconfig(显示网络设备),ping,ps(查看当前时间的进程信息),kill -9 pid(强制终止),grep -i(管道),rmdir(删除目录，如果目录中有文件先必须删除目录中的文件)


195、ORM：
ORM：Object Relational Mapping对象关系映射。
将对象与数据库中表建立映射关系，操作对象就可以操作数据库中表。


196、Hibernate：封装了jdbc，简化了dao层的书写。可扩展性强，当本身功能不够用时，可以自行编码进行扩展。
Hibernate的映射文件只要是一个XML文件就可以了。一般映射命名：类名.hbm.xml。该文件里面是实体类和数据库表的映射。
Hibernate核心配置文件： 默认SRC下有个hibernate.cfg.xml文件。该文件里面是连接数据库的信息、加载.hbm.xml映射文件、hibernate的属性。


197、hibernate代码操作的步骤：
1、加载hibernate核心配置文件
2、创建SessionFactory：session工厂对象。（Session工厂，是一个线程安全的对象，内部维护Hibernate的连接池。一般一个应用只需要创建一次的对象。）
3、从SessionFactory中开启事务
4、操作数据库
5、提交事务

其中session的方法有get,update，delete。其中创建和修改都是update。

get和load的区别：

get使用的是立即加载，也就是马上发送sql语句。
get查询返回的对象是真实对象本身。
get查询一个找不到的对象的时候返回null

load使用的是延迟加载，只有当用到这个对象的非主键信息的时候才会发送sql语句。
load返回的是代理对象。
找不到对象的时候抛出异常。

198、持久化类：
持久化类: 与表建立了映射关系的实体类,就可以称之为持久化类
持久化类 = Java类 + 映射文件


199、持久化类的编写规则：

?提供无参数的构造方法		
?类中的成员都是私有的private					
?对私有属性提供get/set方法	
?属性尽量使用包装类类型							：默认值不同的，包装类默认值null，基本数据类型默认0。
?持久化类不要使用final进行修饰					：使用final修饰，延迟加载失效，变为立即加载。
?类中需要提供标识属性(OID)，与表中主键建立映射关系	：Hibernate根据标识属性来判断对象是否是同一个的。


200、Hibernate的主键生成策略
主键不应该由用户自己维护，应该统一管理，那么Hibernate就提供了主键统一管理的方式：主键生成策略。


?increment		：自动增长，是Hibernate中提供一种自动增长方式，不是数据库中的自动增长。(适用于short、int、long类型的主键(总之是数字))
首先使用select max(cust_id) from cst_customer;将这个最大值+1作为下一条记录的主键。
对于并发访问数据库不适用

?identity			：自动增长，适用于short、int、long类型的主键，使用的是数据库自动增长机制。不是所有数据库都支持自动增长，比如Oracle没有自动增长。 （不可手动设置主键）
?sequence			：序列，适用于short、int、long类型的主键，使用序列方式完成主键的生成。必须是支持序列的方式的数据库。Oracle的自动增长  （不可手动设置主键）

?native			：本地策略，根据底层的数据库不同，自动选择使用identity还是sequence。

?uuid				：随机字符串，适用于字符串类型的主键。

?assigned			：Hibernate不维护主键，开发人员需要手动设置主键。


总结: 以后如果针对是数值型,选择用native （也就是让hibernate自动选择） 如果是varchar类型,可以选择用uuid
     但是也可以不用hibernate维护,自己在程序中手动设定唯一非空(assigned)


201、Hibernate的持久化类的三种状态
Hibernate框架为了更好管理持久化类，将持久化类分成了三种状态：
?瞬时态	：没有持久化标识OID，没有被session操作管理。（刚创建对象没有保存到数据库时）
?持久态	：有持久化标识OID，已经被session操作管理。（保存到数据库之后）
脱管态(离线态)	：有持久化标识OID，没有被session操作管理。（提交事务并关闭session连接之后）


202、持久态与一级缓存中的两个区：

持久态: 只要使用heibernate查询出的对象,就都是持久态对象
  特性: 持久态对象会自动去更新数据库的数据 (一级缓存造成的)

 产生原因:

	session.get(Customer.class, 1L);  // 会去数据查询,查完放在一级缓存中
							一级缓存2个区:
								存储区: 放在这一份
								快照区: 备份一份这这里


	ct.setCust_name("roseabcd");  // 会去一级缓存中修改数据,但是只修改存储区的数据,不修改快照区的数据
								存储区: 修改了
								快照区: 以前没修改的数据


	tx.commit();   // 会去一级缓存中获取存储区和快照区的数据,对比这2个区的数据是否一致
						一致:什么都不操作
						不一致:执行update更新语句更新数据库


	session.close()  // 一级缓存的数据全部清空。也就是连接关闭之后缓存就随之清空了。


203、Hibernate的一级缓存概述
Hibernate框架本身的性能不是很好，但是Hibernate提供了很多的性能优化的手段，比如，缓存。

Hibernate框架共提供了两个级别的缓存：
一级缓存：称为Session级别的缓存。因为一级缓存的生命周期与session一致的。自带的，不可卸载的。(由Session中一系列的Java集合构成的)


二级缓存：称为SessionFactory级别的缓存。需要进行配置的缓存的插件。默认不开启的。ehche   redis

Ps: 除了删除,增改查和数据库打完交道,都会往一级缓存中留一份（注意，删除不留记录）
*********但是session只要关闭*******,一级缓存的数据全部清空


204、ThreadLocal在session上的应用：
Hibernate中设置与当前线程绑定的session的使用（也就是用ThreadLocal修饰session）。


205、在hibernate中,查询批量数据的方式:

Query方式  : 如果是使用这种方式做查询,又被称作为HQL查询

Criteria方式 :  如果是使用这种方式做查询,又被称作为QBC查询


206、Query ：HQL查询
接收一个HQL进行查询：HQL-Hibernate Query Language Hibernate查询语言，与SQL语言语法很相似的一个语言。面向对象。（注意HQL是传入的参数）
	@Test
	/**
	 * Query接口
	 * HQL面向对象的查询.查询都是对象
	 */
	public void demo1(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction transaction = session.beginTransaction();//开启事务
		
		// 查询全部客户信息：
		/*Query query = session.createQuery("from Customer");//替换了原来的get方法
		List<Customer> list = query.list();
		
		for (Customer customer : list) {
			System.out.println(customer);
		}*/
		
		// 条件查询
		/*Query query = session.createQuery("from Customer where cust_name like ?");
		// 设置参数
		query.setParameter(0, "郝%");//0表示第一个问号”?”
		List<Customer> list = query.list();
		for (Customer customer : list) {
			System.out.println(customer);
		}*/
		
		// 分页查询:
		Query query = session.createQuery("from Customer");//可以看出HQL查询都是createQuery方法
		// 从哪开始的
		query.setFirstResult(3);
		// 每页显示记录数
		query.setMaxResults(3);
		
		List<Customer> list = query.list();
		for (Customer customer : list) {
			System.out.println(customer);
		}
		transaction.commit();
	}


207、Criteria ：QBC查询
QBC-Query By Criteria 条件查询。更加面向对象化查询语言。
	@Test
	/**
	 * QBC查询：Query By Criteria
	 */
	public void demo2(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction transaction = session.beginTransaction();
		
		// 查询全部:
	/*	Criteria criteria = session.createCriteria(Customer.class);//将from Customer变成了Customer.class
		List<Customer> list = criteria.list();//从这里往下都和HQL查询一样
		for (Customer customer : list) {
			System.out.println(customer);
		}*/
		
		// 条件查询
	    /**
		 * == 	eq
		 * >	    gt				 
* >=	ge		
		 * <	    lt		
		 * <=	le		
		 * <>	ne		
		 * in   in
		 * like like
		 * 
		 */


		/*Criteria criteria = session.createCriteria(Customer.class);
		// criteria.add(Restrictions.eq("cust_name", "郝天一"));//注意一个like一个eq。
		criteria.add(Restrictions.like("cust_name", "郝%"));
		List<Customer> list = criteria.list();
		for (Customer customer : list) {
			System.out.println(customer);
		}*/
		
		// 分页查询
		Criteria criteria = session.createCriteria(Customer.class);
		criteria.setFirstResult(3);
		criteria.setMaxResults(3);
		List<Customer> list = criteria.list();
		for (Customer customer : list) {
			System.out.println(customer);
		}
		
		transaction.commit();
	}


208、JPA是一套ORM规范(算是一个接口)，hibernate实现了JPA规范(算是一个实现类)


209、JPA的配置文件：在src下面的META-INF文件夹下面创建一个名称为persistence.xml的文件。配置文件的内容为数据库的连接信息等。


210、hibernate常用注解：
@Entity
	作用：指定当前类是实体类。写上此注解用于在创建SessionFactory/EntityManager时，加载映射配置。
@Table
	作用：指定实体类和表之间的对应关系。
	属性：
		name：指定数据库表的名称
@Id
	作用：指定当前字段是主键。
@GeneratedValue
	作用：指定主键的生成方式。JPA的主键生成方式详解见2.4小节的说明。
	属性：
		strategy?：指定主键生成策略。JPA支持四种生成策略，具体介绍看2.4小节。
@Column
	作用：指定实体类属性和数据库表之间的对应关系
	属性：
		name：指定数据库表的列名称。
		unique：是否唯一 ?
			nullable：是否可以为空 ?
			inserttable：是否可以插入 ?
			updateable：是否可以更新 ?
			columnDefinition: 定义建表时创建此列的DDL ?
			secondaryTable: 从表名。如果此列不建在主表上（默认建在主表），该属性定义该列所在从表的名字。 ?


211、JPA代码操作：

先编写工具类获得实体管理工厂EntityManagerFactory：
 public final class JPAUtil {
	//JPA的实体管理器工厂：相当于Hibernate的SessionFactory
	private static EntityManagerFactory em;
	//使用静态代码块赋值
	static {
		//注意：该方法参数必须和persistence.xml中persistence-unit标签name属性取值一致
		em = Persistence.createEntityManagerFactory("myPersistUnit");
	}

	/**
	 * 使用管理器工厂生产一个管理器对象
	 * @return
	 */
	public static EntityManager getEntityManager() {
		return em.createEntityManager();
	}
}

使用JPAUtil工具类：
/**
	 * 保存一个实体
	 */
	@Test
	public void testAdd(){  
		//定义对象
		Customer c = new Customer();
		c.setCustName("传智学院");
		c.setCustLevel("VIP客户");
		c.setCustSource("网络");
		c.setCustIndustry("IT教育");
		c.setCustAddress("昌平区北七家镇");
		c.setCustPhone("010-84389340");
		EntityManager em=null;  //这应该是工具类中的内容
        EntityTransaction tx=null;  
        try{  
        	//获取实体管理对象
        	em=JPAUtil.getEntityManager();
        	//（从实体管理对象里面）获取事务对象
        	tx=em.getTransaction();
        	//开启事务
        	tx.begin();
        	//执行操作,相当于session.save
        	em.persist(c);
        	//提交事务
        	tx.commit();  
        }catch(Exception e){
        	//回滚事务
        	tx.rollback();
        	e.printStackTrace();  
        }finally{  
        	//释放资源
            em.close();  
        }    
    }

其中JPA的增删改查操作的方法分别为：em.persist(对象)，Customer c=em.find(Customer.class,6L)---em.remove(c),Customer c=em.find(Customer.class,6L)---c.setXXX(),em.find(Customer.class,6L)

crud:
		persist()
			----保存

		find()  : 立即加载
		getReference():延迟加载
			-----单条数据的oid查询

		merge()（合并，吞没）
			---修改

		
		remove()
			---删除


212、Jpa延迟加载：
Customer c1 = em.getReference(Customer.class, 1L);


213、JPA和HQL,QBC的关系：JPA既可以用HQL方法查询又可以用QBC方法查询。


214、数据库实体类实现Serializible序列化接口的原因：只有实现了序列化接口才能从内存中序列化到磁盘上。当传递对象信息时（例如分布式的项目之间传递对象信息），
传递的是对象的地址，只有序列化到磁盘上才会有地址。


215、数据库表一对多的操作：先保存主表再保存从表，先删除从表再删除主表。假如想在从表没删除之前删除主表，就要使用（配置）级联删除。
级联:
		cascade=CascadeType.ALL  做级联保存以及级联删除
		cascade=CascadeType.PERSIST 只做级联保存
		cascade=CascadeType.REMOVE 只做级联删除


216、在多对多的删除时，双向级联删除根本不能配置（也就是禁用，因为会来回删除，几乎删除了所有数据）


217、5.2JPA和hibernate中操作数据的方法对照：
JPA：persist(),merge(),remove，find(),使用HQL语句
hibernate：save(),update,delete()，get(),使用JPQL语句


218、Struts2的执行流程
页面发送请求，请求先到达前端控制器（核心过滤器StrutsPrepareAndExecuteFilter），过滤器中执行一组拦截器，这组拦截器完成了部分的功能代码。如果没有拦截器，就会执行目标Action。执行Action后返回一个逻辑视图名称。根据Result进行页面跳转。


219、struts.xml中配置
核心配置文件，主要负责管理Action
??	通常放在src目录下，在该目录下的struts.xml文件可以被自动加载


220、Struts2中Action的3种创建方式
1）普通的Java类
2）实现Action接口
3）继承ActionSupport类


221、Struts2中Action方法的3种访问方式
1）动态方法访问

2）通过method属性配置

3）通过通配符的配置方式：

<action name= "*User"  class="cn.jbit.houserent.action.UserAction" method="{1}">
   <result name=”success”>/{1}_success.jsp</result>
   <result name="input">/{1}.jsp</result>
   <result name="error">/error.jsp</result>
</action>

说明：
编写form表单中action=”loginUser.action”
则struts.xml中的代码相当于
method="login"
/login_success.jsp
/login.jsp
	

222、Struts2模型驱动：
（模型驱动就是要实现ModelDriven<>接口）
Action:
public class CustomerDemo3Action extends ActionSupport implements ModelDriven<Customer>{
	private Customer customer = new Customer(); // 必须手动创建对象。
	// 模型驱动使用的方法:
	@Override
	public Customer getModel() {（由getCustomer()变成了getModel()）
		return customer;
	}
	@Override
	public String execute() throws Exception {
		System.out.println(customer);
		return NONE;
	}
}


223、是否经过后台要看链接是*.jsp还是*.action。


224、先经过web.xml的过滤器，在经过拦截器。拦截器的定义：

拦截器是Struts2对Action访问的拦截。拦截器是Struts2的执行的核心。
过滤器是从客户端向服务器发送的请求的拦截。
拦截器执行流程（区分过滤器和拦截器）
客户端请求Action，执行核心过滤器，在核心过滤器内部创建了Action的代理类，调用代理类的execute方法，在execute方法内部执行ActionInvocation的invoke方法。在invoke方法内部递归调用拦截器的拦截的方法。如果没有下一个拦截器执行目标Action，Action执行结束后根据Result进行页面跳转，执行拦截器的后面相应的代码，最后由response对象生成响应。
拦截器的执行时机
	在访问struts2核心内部时，在动作方法执行之前先正序执行，然后执行动作方法，执行完动作方法和结果视图之后，再倒序执行。所以它是先进后出，是个栈的结构。具体可参考下图：


自定义拦截器（区分编写拦截器和配置拦截器）
【编写拦截器类】
编写拦截器的类实现Interceptor接口，继承AbstractInterceptor，或者只继承MethodFilterInterceptor。

【配置拦截器】（区分拦截器和拦截器栈）
1、配置拦截器

2、配置拦截器栈


编写权限的拦截器（拦截器也是一个类，是一个单独的类文件）
public class PrivilegeInterceptor extends MethodFilterInterceptor {

	@Override
	protected String doIntercept(ActionInvocation invocation) throws Exception {
		// 判断session中是否有登录的用户的信息。
		User existUser = (User) ServletActionContext.getRequest().getSession().getAttribute("existUser");
		// 如果有信息放行，没有的话回到登录页面。
		if(existUser == null){
			// 说明没有登录过。
			return "login";
		}else{
			// 已经登录成功。相当于放行（原来参数里面的invocation是在这里使用）（不用写转到哪个页面，写放行就行）
			return invocation.invoke();
		}		
	}

}
配置拦截器（分为定义拦截器和使用拦截器，其中使用拦截器可以用配置文件或者注解，而定义拦截器只能用配置文件）
【定义拦截器，在Action中配置拦截器】（在action的上面定义拦截器，在action里面引用拦截器）
	<package name="crm" extends="struts-default" namespace="/">
		<!-- 定义拦截器 -->
		<interceptors>
			<interceptor name="privilegeInterceptor" class="com.itheima.crm.web.interceptor.PrivilegeInterceptor"/>（不用有结束标签）
		</interceptors>
	
		<action name="customer_*" class="com.itheima.crm.web.action.CustomerAction" method="{1}">
			<result name="findAll">/jsp/customer/list.jsp</result>
			<result name="saveUI">/jsp/customer/add.jsp</result>
			<result name="saveSuccess" type="redirectAction">customer_findAll.action</result>（不仅可以到jsp页面还可以到action中，只是要设置type属性的值）
			
			<!-- 引用拦截器 -->
			<interceptor-ref name="privilegeInterceptor"/>（ref表示reference，也就是引用）
			<!-- 一旦引用了自定义拦截器，默认拦截器就不执行了。 需要将默认拦截器引入进来。-->
			<interceptor-ref name="defaultStack"/>（也可以直接引用一个拦截器栈，他就包含了所有的拦截器和默认拦截器栈，标签名字依然是intercepter-ref）
		</action>
		
		<action name="user_*" class="com.itheima.crm.web.action.UserAction" method="{1}">
			<result name="login">/login.jsp</result>
			<result name="loginSuccess" type="redirect">/index.jsp</result>
		</action>
	</package>


【定义拦截器栈，在Action中引用拦截器栈】（区分定义拦截器和定义拦截器栈，后者可以没有，但是前者一定要有，即使定义了拦截器栈也要定义拦截器，因为拦截器中有对应的拦截器类文件的地址。注意，拦截器intercepter和拦截器栈intercepter-stack都在intercepters元素的内部）（定义拦截器和引用拦截器都在配置文件struts.xml中，只是定义拦截器在action外，引用拦截器在action内）


225、Struts2注解见Struts2第四天


226、@Action注解就对应于原来的xml中的Action元素。


227、Spring的优点见spring第一天。（ioc,aop,junit4方便测试，集成其他优秀框架，封装jdbc等简化代码，声明式事务的支持）


228、IOC:控制反转。用反射的方式将对象的创建权反转（交）给Spring。
     DI:依赖注入。依赖IOC，注入属性值。

229、依赖注入的各种方式：

1、属性注入：
	构造方法注入
	<bean id="car1" class="com.itheima.demo4.Car1">
		<constructor-arg name="name" value="宾利"/>
		<constructor-arg name="price" value="9980000"/>
	</bean> 

	set方法属性注入
	<bean id="car2" class="com.itheima.demo4.Car2">
		<property name="name" value="三轮"/>
		<property name="price" value="5000"/>
	</bean>

	对象类型属性注入
	<bean id="emp1" class="com.itheima.demo4.Employee">
		<property name="username" value="宝强"/>
		<property name="car" ref="car1"/>
	</bean>

	p名称空间
	xmlns:p="http://www.springframework.org/schema/p"
	<bean id="emp2" class="com.itheima.demo4.Employee" p:username="王蓉" p:car-ref="car2"></bean>

	SpEL表达式
	<bean id="car1" class="com.itheima.demo4.Car1">
		<constructor-arg name="name" value="#{'宾利'}"/>
		<constructor-arg name="price" value="#{calc1.calc()}"/>
	</bean>

2、集合类型属性注入
	<!-- 给数组赋值 -->
	<property name="arr">
		<array>
			<value>aa</value>
			<value>bb</value>
			<value>sb</value>
			<value>cc</value>
			<value>mm</value>
		</array>
	</property>
	
	<!-- 给list集合赋值 -->
	<property name="list">
		<list>
			<value>aaa</value>
			<value>bbb</value>
			<value>ccc</value>
			<ref bean="car1"/>
		</list>
	</property>
	<!-- 给set集合赋值 -->
	<property name="set">
		<set>
			<value>aaaa</value>
			<value>bbbb</value>
			<value>cccc</value>
			<ref bean="car2"/>
		</set>
	</property>
	


230、Spring开启注解需要在xml文件中进行配置：

在spring的配置文件中开启spring对注解ioc的支持
<!-- 告知spring框架在，读取配置文件，创建容器时，扫描注解，依据注解创建对象，并存入容器中（原来创建的对象存在于容器中） -->
	<context:component-scan base-package="com.itheima"></context:component-scan>


231、JDK动态代理：
1、什么代理？
一个类不能或不适合访问目标类，可以使用代理类。

2、它能解决什么问题？
  可以不改变目标类，对目标方法进行功能增强。


232、AOP意为面向切面编程，原理是运行期动态代理。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得各个部分的耦合度降低，提高了程序的可重用性，提高了开发效率。
AOP是OOP的延伸和扩展。AOP取代传统的纵向继承机制，是横向抽取机制。

AspectJ：本身就是一个面向切面的框架，Spring把AspectJ引入进来作为自身AOP的开发。



233、Spring实现AOP使用两种代理机制：
		* JDK动态代理	:基于接口实现（动态代理代理的是类而不是方法）（其实AOP核心就是将切入点传入切面并配置切面中的各种增强方法给他）	
		* Cglib动态代理	:基于子类实现


234、JDK实现动态代理的原理：将业务类传入代理工厂，用代理工厂中的invoke方法对业务类进行加工和扩展，返回一个新的代理加工之后的业务类对象。
其中invoke方法有三个参数，第一个是代理对象本身的引用，第二个是代理对象调用的方法，第三个是方法中的参数。


235、Spring的AOP中的通知的详解(所有通知都算是执行增强)
【前置通知】
指的是在目标方法执行之前执行一段增强。
【后置通知】
指的是在目标方法执行之后执行一段增强。后置通知获得方法的返回值。
【环绕通知】
指的是在目标方法执行之前和之后进行增强。阻止目标方法执行。
【异常抛出通知】
指的是在目标方法执行出现异常的时候执行的。获得到异常的信息。
【最终通知】
指的是无论是否有异常，总是被执行的。


236、//Aspect：切面类（切面类里面有各种增强（通知）方法）
public class MyAspect {
    //advice:通知/增强
	public void privilegeUser(){
		System.out.println("校验用户权限执行了。。。");
	}
	
	//后置增强
	public void afterReturning(){
		System.out.println("后置增强执行了。。。");
	}
	//环绕通知
	public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable{
		System.out.println("目标方法执行前。。。"+System.nanoTime());
		proceedingJoinPoint.proceed();//执行目标方法
		System.out.println("目标方法执行后。。。"+System.nanoTime());
	}
	//异常通知
	public void afterThrowing(){
		System.out.println("异常增强执行了。。。");
	}
	//最终通知
	public void after(){
		System.out.println("最终增强执行了。。。");
	}
	
}

xml配置文件里面主要分为切面类，目标类以及声明AOP配置
<!-- 创建业务类（目标类） -->
	<bean id="customerService" class="cn.itcast.service.impl.CustomerServiceImpl"></bean>
	
	<!-- 创建切面类 -->
	<bean id="myAspect" class="cn.itcast.aspect.MyAspect"></bean>
	
	 <!-- 声明aop的配置 （分为配置切入点和配置切面，其中后者引用前者的id，前者相当于为后者服务）-->（区分切入点和切面，前者是待增强方法，后者中是各种增强方法）
	 <aop:config>
	 	<!-- 1、切入点：真正被增强的方法  （配置哪些目标类中的哪些方法 要被增强） -->
	 	<aop:pointcut expression="execution(* cn.itcast.service.CustomerService.add*(..))" id="pointcut1"/>
	 	<aop:pointcut expression="execution(* cn.itcast.service.CustomerService.update*(..))" id="pointcut2"/>
	 	<aop:pointcut expression="execution(* cn.itcast.service.CustomerService.delete*(..))" id="pointcut3"/>
	 	<!-- 2、配置AOP的切面（pointcut-ref表示引用切入点）（需要引用切面类文件） -->
	 	<aop:aspect ref="myAspect">
	 		<!-- 配置前置通知 -->
	 		<aop:before method="privilegeUser" pointcut-ref="pointcut3"/>
	 		<!-- 配置后置通知 -->
	 		<aop:after-returning method="afterReturning" pointcut-ref="pointcut1"/>
	 		<!-- 配置环绕通知 -->
	 		<aop:around method="around" pointcut-ref="pointcut2"/>
	 		<!-- 异常通知 -->
	 		<aop:after-throwing method="afterThrowing" pointcut-ref="pointcut3"/>
	 		<!-- 配置最终通知 -->
	 		<aop:after method="after" pointcut-ref="pointcut3"/>
	 	</aop:aspect>
</aop:config>


237、<!-- 开启aop注解 -->
  	<aop:aspectj-autoproxy/>


238、Spring的AOP的注解介绍（也就是各种通知的@写法）
@Aspect		：定义切面类 

@Before		:前置通知
@AfterReturning:后置通知
@Around		:环绕通知
@AfterThrowing:异常抛出通知
@After		:最终通知

@Pointcut	:定义切入点


239、Spring配置文件中可以配置c3p0数据源或dbcp数据源（也就是连接池）


240、配置事务步骤
第一步：配置事务管理器（区分・配置事务和配置事务管理器）
<!-- 配置事务管理器 -->
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
//配置事务管理器要有数据源
		<property name="dataSource" ref="dataSource"/>
	</bean>
第二步：配置事务的增强（区分配置事务管理器和事务管理器的增强。只有先配置才能增强）
	<!-- 配置事务的增强 -->
	<tx:advice id="txAdvice" transaction-manager="transactionManager">
		<tx:attributes>
<!-- 指定方法名称：是业务核心方法 
	read-only：是否是只读事务。默认false，不只读。
	isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。 
	propagation：指定事务的传播行为。
	timeout：指定超时时间。默认值为：-1。永不超时。（看来等待时间很长）
	rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。没有默认值，任何异常都回滚。
	no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回滚。没有默认值，任何异常都回滚。
	-->
//主义还可以带星号代表方法的一部分
			<!-- <tx:method name="save*" propagation="REQUIRED" />
			<tx:method name="update*" propagatio="REQUIRED"/>
			<tx:method name="delete*" propagation="REQUIRED"/>
			<tx:method name="find*" read-only="true"/> -->
			
			<tx:method name="transfer" propagation="REQUIRED"/>
		</tx:attributes>
	</tx:advice>
第三步：配置事务的AOP
	<!-- 配置事务的AOP -->
	<aop:config>
		<aop:pointcut expression="execution(* com.itheima. service.AccountServiceImpl.*(..))" id="pointcut1"/>//用id标记待加强的方法（待配置事务的方法）
		<!-- Advisor:Spring的传统的切面（一个切入点和一个切面的组合） 和 Aspect:Spring真正切面（多个切入点和多个通知的组合） -->（txAdvice相当于增强规则）（-ref前面的就是aop:后面的）
		<aop:advisor advice-ref="txAdvice" pointcut-ref="pointcut1"/>
	</aop:config>


241、spring要支持事务的注解必须先在配置文件里面开启）（annotation:注解）
<!-- 开启spring对注解事务的支持 -->//引入的是事务管理器的id
<tx:annotation-driven transaction-manager="transactionManager"/> 


242、ssh三大框架的整合：
a.独立式整合指的是三个框架都使用自己的配置文件。
b.引入式整合指的是hibernate主配置文件中的内容都配置到spring配置文件中

243、spring和hibernate的整合：
Spring和Hibernate的整合就是spring接管SessionFactory（原本存在于hibernate的核心配置文件hibernate.cfg.xml中）的创建（本来SessionFactory属于hibernate框架，相当于连接池）


244、配置Spring事务的步骤：
配置事务管理器并注入SessionFactory---配置增强事务管理器（配置事务通知及通知的属性）---配置AOP建立切入点表达式和事务通知的关系。


245、整合Spring和Hibernate的步骤：
在Spring配置文件中配置SessionFactory（区分配置连接池和注入连接池）
改造dao继承HibernateDaoSupport
在Spring配置文件中给Dao注入SessionFactory（连接池）
去掉Session绑定到当前线程上（也就是修改hibernate配置文件）（也就是不再绑定session）
最后一步的作用（原因）
是由于spring的HibernateTemplate对象在使用Session时，spring创建了Session的代理对象，在这个过程中，spring对hibernate绑定Session到当前线程的配置不认识了，所以运行失败。（也就是用session的代理对象代替了session）


246、spring整合struts2：从spring容器中获取类：
ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
		//由于动作类是多例的，每次都会创建容器，导致资源的浪费。一个应用应该只有一个容器
		customerService = (CustomerService) ac.getBean("customerService");
优化方法：
只要让容器在应用加载时创建(也就是只有在应用加载时才创建一次容器，其他时候不创建)，应用卸载时销毁就可以。
Spring框架为我们提供了一个监听器：ContextLoaderListener。
它是ServletContextListener接口的实现类，负责监听ServletContext对象的创建，为我们创建容器，监听ServletContext对象的销毁，销毁容器。(注意该实现类还可以创建容器和销毁容器)
<listener>
    <listener-class>
		org.springframework.web.context.ContextLoaderListener
	</listener-class>
</listener>
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:applicationContext.xml</param-value>
</context-param>


247、Action的两种管理方式：struts2自己管理和spring管理（实际使用）


248、引入式整合就是把hibernate.cfg.xml中的配置都挪到spring的配置文件中


249、4.2.3.2使用注解配置Action
/**
 * 客户的动作类
 */
@Controller("customerAction")
@Scope("prototype")//将单例模式转变成多例模式，即每次请求都创建一个action对象*******************************
//-------以下都是struts2的注解-----------
@ParentPackage("struts-default")//指定当前包的父包
@Namespace("/")//指定名称空间，访问当前action的所有方法都需要有名称空间
public class CustomerAction extends ActionSupport implements ModelDriven<Customer> {
	private Customer customer = new Customer();
	
	@Autowired
	private ICustomerService customerService;	
	
	@Override
	public Customer getModel() {
		return customer;
	}
	
	/**
	 * 查询所有客户
	 * @return
	 */
	private List<Customer> customers;
	//用于配置动作名称
	@Action(value="findAllCustomer",results={
//这是个数组，可以配置多个结果
			@Result(name="findAllCustomer",
					type="dispatcher",
					location="/jsp/customer/list.jsp")
	})
	public String findAllCustomer(){
		customers = customerService.findAllCustomer();
		return "findAllCustomer";
	}
	
	/**
	 * 获取添加客户页面
	 * @return
	 */
	@Action(value="addUICustomer",results={
			@Result(name="addUICustomer",
					location="/jsp/customer/add.jsp")
	})
	public String addUICustomer(){
		return "addUICustomer";
	}
	
	/**
	 * 添加客户
	 * @return
	 */
	@Action(value="addCustomer",results={
			@Result(name="addCustomer",
					type="redirect",
					location="/jsp/success.jsp")
	})
	public String addCustomer(){
		customerService.saveCustomer(customer);
		return "addCustomer";
	}
	
	public List<Customer> getCustomers() {
		return customers;
	}
	public void setCustomers(List<Customer> customers) {
		this.customers = customers;
	}
}


250、mysql分页查询：limit 1,2  查询第一页，每页两条数据。

oracle分页查询：

SELECT * FROM  
(  
SELECT A.*, ROWNUM RN  
FROM (SELECT * FROM TABLE_NAME) A  
WHERE ROWNUM <= 40  
)  
WHERE RN >= 21


251、集合运算：

?集合运算的特征
集合运算两边查询的字段数量、字段类型、顺序必须一致

?并集
    
范例：工资大于1500，或者是20号部门下的员工（并集）
select * from emp where sal>1500
union  -- 或union all 
select * from emp where  deptno=20;

?交集

范例：工资大于1500，并且是20号部门下的员工（交集）
select * from emp where sal>1500
intersect --交集
select * from emp where  deptno=20;

?差集

--范例：1981年入职的普通员工（不包括总裁和经理）（差集）
select * from emp where to_char(hiredate,'yyyy')='1981'
minus
select * from emp where job='PRESIDENT' or job='MANAGER'


252、约束：主键约束 primary key，外键约束，唯一约束 unique，非空约束 not null,检查约束 check(列名 in (1,2))


253、视图：
视图是一条封装了复杂查询的语句，是一个虚表，最大的优点是简化复杂的查询。不建议通过视图对表中的数据进行修改，因为会受到很多限制。
视图举例：create view aa as select * from emp where 。。。。


254、索引：是用于加速数据存取的数据对象。降低i/o次数，提高数据库的访问性能。
单列索引（基于单个列建立的索引）：create index 索引名 on 表名（列名）
符合索引（基于多个列建议的索引）：create index 索引名 on 表名（列名，列名）


255、pl/sql：在sql的基础上增加了过程处理语句（分支、循环等）。


256、游标cursor：
在写java程序中有集合的概念，pl/sql中也会用到多列记录，而游标可以存储查询返回的多条数据。
游标的使用步骤：
打开游标---取一行游标的值---关闭游标---结束游标


257、存储过程：
存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象，任何一个设计良好的数据库应用程序都应该用到存储过程。


258、maven配置本地仓库：maven-3.3.9\conf\settings.xml--------localRepository元素中配置路径

maven的三种仓库：本地仓库，远程仓库，中央仓库。

maven重建索引：maven repositories---local repositories---local repository

Maven的好处：
节省空间（jar包都放在一个工程里面，其他项目都可以直接引用这个工程里面的jar包而不用自己复制一份。但是最初被引用的会从仓库中复制一份）
一键构建
跨平台
大型项目提高开发效率


259、依赖传递


260、父工程：类型该为pom


261、多对多查询

表Task： taskID,taskName
表Person: personID, personName
表TaskPerson: taskID，personID
每个任务有多个人担当，每个人同时也担当多人任务。
求教SQL文，查询1：每个任务对应的担当者
查询2：每个人承担的任务

防止出现有任务没有对应的人担当，因此用left join防止漏掉任务
  
查询1：每个任务对应的担当者  
SELECT t.taskID, t.taskName, tp.personID, p.personName
FROM task t
LEFT JOIN TaskPerson tp ON t.taskID = tp.taskID
LEFT JOIN Person p ON p.personID = tp.personID

查询2：每个人承担的任务
SELECT p.personID, p.personName, tp.taskID, t.taskName
FROM Person p
LEFT JOIN TaskPerson tp ON p.personID = tp.personID
LEFT JOIN Task t ON t.taskID = tp.taskID