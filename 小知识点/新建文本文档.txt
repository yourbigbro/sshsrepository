1、git中远程仓库的内容可以直接拉到eclipse的工作区中，但是eclipse工作区中的内容不能直接提交到git远程仓库，只能先提交到本地仓库。


2、创建git仓库的三种方法：
   1）用命令的方式创建git版本仓库：右键--Git Bash Here--输入git init命令（git版本仓库就是.git隐藏文件）
   2）右键--Git在这里创建版本仓库--在制作纯版本库（没有工作目录）上打钩--确定（没有.git隐藏文件，没有目录，直接就是仓库（也就是.git隐藏文件中的内容））
   3）右键--Git在这里创建版本仓库--不在制作纯版本库（没有工作目录）上打钩--确定（有.git隐藏文件）


3、git操作文件：
   1）将文件添加到git管理：（原理是先将工作区中的内容提交到暂存区，再将暂存区中的内容提交到本地git仓库）在目标文件上右       键--TortoiseGit(T)--添加--文件上出现加号--在文件上右键--Git提交--添加日志信息--确认--文件上出现对号，添加成功
   2）修改文件之后提交到git仓库：在文件上右键--Git提交--添加日志信息--确认
   3）查看日志：在目标文件上右键--TortoiseGit(T)--显示日志
   4）修改之后比较差异：在目标文件上右键--TortoiseGit(T)--比较差异--有加号的代码行就是新增的
   5）将文件还原到上一个版本：在目标文件上右键--TortoiseGit(T)--还原
   6）删除git中管理的文件：
      1）在目标文件上右键--TortoiseGit(T)--删除（同时删除了仓库中的文件和本地文件）
      2）在目标文件上右键--TortoiseGit(T)--删除并保留本地副本--文件上出现叉号（保留了本地文件）


4、git管理java项目：
   不提交bin文件夹，因为里面是编译之后的二进制文件。在bin文件夹上右键--TortoiseGit(T)--删除并添加到忽略列表--bin-递归     忽略文件或目录--.gitignore放在文件/文件夹所在的目录--确定（操作的结果是java项目中出现了一个.gitignore文本文件，里面   是被忽略的   bin文件夹，这使得其他人在提交项目时也无法提交bin文件夹）


5、linux命令ll和ls的区别：
   ll是会显示当前目录下的文档详细信息（包括权限、所属用户和组、大小、时间、名称等），是ls -l的缩写，相当于windows的快   捷方式；ls只显示当前目录下的文档名。


6、打pom包的情形：
                1）管理maven依赖的父工程
                2）聚合工程父工程

   打war包的情形：需要部署tomcat。打war包的工程有web.xml配置文件。

   打jar包的情形：被其他项目引用的情况。可以用排除法，也就是只要既不是pom包又不是war包就是jar包。
总之，从上到下依次是pom,jar,war。


7、创建maven工程的四个步骤：创建工程，添加依赖，配置文件，静态页面。


8、配置tomcat端口号的两个方法：
                             1）pom.xml里面，在build--plugins--plugin元素里面添加configuration元素，再在configuration元素里面添加port和path元素。
                             2）conf文件夹里面的server.xml里面配置


9、SqlMapCofig当配置文件为空时是可以没有的。


10、聚合工程父工程下的子工程会首先汇集到父工程然后再执行，因此配置文件可以随便放，最后总会到父工程里面被所有的工程所用。可以统一放在war工程里面看起来更清晰一些。


11、当使用dubbo之后，@Service注解分为阿里巴巴的注解和spring原生的注解，前者在使用事物时会出问题，所以还是用原生的注解。


12、如果需要跳转页面，就需要走视图解析器，就一定不能加@ResponseBody注解。假如既需要跳转页面又需要将java对象转换成json，那么就要在后台手动将java转换成json，然后封装进model返回前台页面。
    如果需要返回数据，就需要走转换器，就一定要加@ResponseBody注解。
    区分视图解析器和转换器。


13、Maven中是有配置文件的，在conf/settings.xml中。该配置文件中配置了maven仓库的路径。


14、add dependency是添加依赖，add plugin是不知道。。


15、controller层依赖service接口只是使得前者可以调用后者，但仍然会报错，因为需要开启服务前者才能真正调用后者。


16、@ResponseBody注解的作用：
                           1）转换数据类型
                           2）还有避免走视图解析器。因此即使不需要转换数据类型也要加上该注解


17、打包install的顺序：父子关系的只打父包就行了（但是只有maven module的才不需要给子模块打包，maven project的仍然需要给子项目打包），依赖关系的先打包被依赖项目再打包依赖项目。顶级项目也需要打包。


18、使混乱的代码对齐的方法：
                          1）右键--source--format
                          2）ctrl+shift+f


19、加上、去掉注释：ctrl+shift+c


20、alt+shift+j给方法添加注释。光标需要在方法名上。


21、当前台传来的参数只有一个并且是简单数据类型时，用${}时必须是value，用#{}则随意，只要不为空就行。


22、sellect * from `user` where `name` like '%${value}%'中，要注意前面的两个不是单引号。


23、通用mapper的输入参数可以省略，输出参数resultType不能省略。


24、.gitignore中应该忽略的文件为：/target/、.settings、.project、.classpath。
               应该提交的文件夹为：src、pom.xml


25、将eclipse中的项目放入远程git私服的流程为：
                                           1）右键--team--share project（项目上出现了问号，放入了工作空间。此时在git窗口编辑.gitignore配置文件）
                                           2）右键--team--add to index（项目上出现了星号，放入了暂存区）
                                           3）右键--team--commit（项目上出现了柱形，放入本地仓库）
                                           4）右键--team--push branch master（仍然是柱形，放入了远程仓库）


26、将eclipse中git页面中下载好的工程导入到开发界面中的方法：右键--import projects--import as general project--定义工程名--确定。--------但是此时eclipse并不知道这是个什么类型的项目，因此在项目上（前提是这是一个maven项目的话）：右键--configure（这个单词翻译成配置）--convert to maven project。


27、eclipse中的git解决冲突的两种方法：
                                    1）在冲突的类文件上右键--team--merge tool（merge翻译成融入）

                                    2）修改之后在冲突的类文件上右键--team--add to index。这样之后项目上就有了星号，然后再提交到本地仓库，最后再提交到远程仓库即可。


28、git的右键--team中那几个提交和拉取的区别是什么？？？？？？？


29、只有war项目中中有web.xml文件，只有pom项目中有pom.xml文件。tomcat（包括tomcat端口）是配置在pom.xml文件中的。端口的port元素下面还可以设置path元素来控制访问路径，设置了port之后就不能再在访问路径里面加项目名。


30、linux进入文件：vim+文件名。开启编辑：i。退出编辑：esc+ctrl+zz


31、dubbo改造的方法：分别在服务端和客户端的application-*.xml中添加dubbo约束和配置dubbo暴露端口。


32、zookeeper和dubbo的关系：zookeeper是dubbo的三种连接方式之一。zookeeper的配置方法是分别在服务端和客户端的application-*.xml中进行配置。zookeeper注册中心的作用是注册服务和查找服务。zookeeper是需要开启服务的，不是配置完了打开虚拟机就完事了，光打开虚拟机不行。


33、@RequestMapping("test/{page}/{rows}")里面的字符串里面有{}，但是和他对应的@Pathvariable("page")里面就没有{}。另外，里面还可以有参数为method=RequestMethod.get。不写的话get和post都可以。


34、本地hosts文件（或DNS）与ngnix反向代理服务器配合的过程：域名--hosts文件--域名和ip地址（注意这里的ip地址是不带端口的）--根据ip地址找到ngnix反向代理服务器，并让ngnix反向代理服务器通过域名映射到带端口的ip地址。


35、@RequestParam(value="要接收的前台传来的属性名",defaultValue="该属性名没有属性值时的默认值")


36、@RequestParam和@PathVariable的应用场景区别在于前者的url格式为...?a=1，后者的url格式为.../1


37、当pom.xml文件里面设置path元素时，url中不写项目名，前台页面的js,css等资源的相对路径正常写或者根据@RequestMapping()加上几个../都行；当没有path元素时，不仅访问的url要写项目名，前台引入的css等资源的相对路径还要根据@RequestMapping()注解加上../。注解中总共有几个层级就要加上几个../。因此，应该在pom.xml文件中加上path元素，这样就不用一直修改css等资源的相对路径，也不用将它们修改成绝对路径。


38、打开多个ngix的时候再访问项目会报错。由于打开nginx不管成功还是失败都是黑框一闪，所以不打开任务管理器的话就无法轻松地看见nginx是否已经启动了以及是否启动了多个。


39、查看端口占用情况的命令：netstat -ano
    nginx的三个命令：start nginx.exe   nginx.exe -s stop   nginx.exe -s reload


40、当直接输入目标的ip地址和端口号时，就不走反向代理和hosts文件了，直接到达目标。输入域名和端口号时，只走hosts文件（为了获得目的地的ip地址）不走反向代理（因为已经有了端口号，不必从nginx中获得端口号）。因此nginx配置文件nginx.conf中的listen对应的端口号只能是默认端口号80，为了在域名后面不输入端口号时从nginx中获得真正的前台Controller地址。并且用于输入的端口绝不可能是80，因为这样的话就不走反向代理了，而真正的端口号为了不和listen的80重合而必然不是80，因此用户输入80端口号的话永远是404找不到页面错误。


41、hosts文件中映射的是域名和ip地址，是没有端口在里面的。

42、当重新配置了nginx的配置文件nginx.conf之后，需要对nginx进行reload，但是项目不用重新开启。该配置文件中将listen（也就是监听）的属性值设置为80是因为浏览器中当不输入端口时默认是80，而listen也监听的是80就使得用户不用在url中输入端口。事实上，一旦输入端口就不会再走nginx了。


43、zookeeper每增加一个接口就要在application-service.xml和application-dao.xml中分别多配置一个dubbo元素用来注册服务和查找服务


44、在eclipse中配置tomcat图片服务器的方式（也就是配置保存图片的路径）：双击tomcat服务器--modules--add web module--配置path。这样的话，将图片存入到该path路径时就会将图片存入webapps文件夹下。


45、将项目安装到本地仓库：右键--run as--maven install。


46、反斜杠的转义问题解决方法：
                            1）改成正斜杠
                            2）再加一个反斜杠


47、选中接口之后ctrl+t查看它的实现类


48、.properties配置文件要被spring加载，也就是需要在.xml文件里面：
                                               <context property-placeholder location="classpath:**/**.properties" />
在代码中使用该配置文件中的键值对的方法是：
                                         @Value("${aa}")
                                         private String aa;


49、网络的状态发生变化时（比如网卡被修改了）dubbo就可能出问题，比如找不到已经发布的服务。解决方式是重新启动作为dubbo服务端的项目。


50、序列化：将对象的状态信息转换成可以存储或传输的过程。传递对象传递的其实是对象的引用，也就是对象的内存地址，无法在项目之间传递。字符串可以传递是因为字符串已经在内部做了序列化。


51、zookeeper的启动方式：
                        进入bin目录启动zookeeper：
                                                [root@itcast-01 bin]# pwd
                                                /usr/local/zookeeper-3.4.6/bin
                                                [root@itcast-01 bin]# ./zkServer.sh start  


52、linux回到根目录：cd /root


53、SEO静态化之后经过过滤器*.html的index.html能够进入index.jsp是因为在前端过滤器去掉了.html之后就只剩下了index，再用springmvc.xml中的视图解析器加上前缀和后缀之后就可以通过返回接收的参数字符串而直接跳转到相应的jsp页面。SEO搜索引擎优化是为了提高页面在搜索引擎中的权重，从而更靠前。


54、为了后台代码容易写，可以将json变成自己创建的pojo，或者map。毕竟都属性和属性值的形式。假如有多个map，还可以将这些map放在list集合中。


55、每次修改代码之后都要重新打包，但是引入依赖却只需要一次。


56、用private static final ObjectMapper MAPPER = new ObjectMapper();和String json = MAPPER.writeValueAsString(picUploadResult);将pojo或集合转换成json是变成了字符串格式的json，因此返回类型是String。


57、redis的两种持久化方案：
                         1）RDB快照：把内存中的数据来一份一摸一样的放在硬盘中。优点是数据量小，节省空间，因为只保存当前数据库的状态不保存增删改的                                     记录。缺点是在数据量大的情况下会出现卡顿，但是还原的所用的时间短。
                         2）AOF命令保存日志：将每一条对redis的写操作命令，保存到类似日志文件中。缺点是需要的空间大，优点是加载到内存中的时候可以                                             一条一条的执行，不会出现卡顿。但是还原的时间会比较长。AOF的另一个优点是可以利用日志修改误操作，再执                                             行一遍十分方便。


58、linux3.0以上才支持集群。


59、pwd：显示当前完整目录名。


60、vim 文件名 表示要修改某个文件。


61、在文件里面/***表示要在文件中寻找字符串***。假如找到多个符合要求的字符串，按n表示跳到下一个符合要求的字符串。


62、shift zz命令为保存退出。


63、ctrl c结束程序


64、select 0表示选择第一个redis数据库。


65、创建shell脚本：vim ****.sh--编写shell脚本--保存退出--./*****.sh来执行该脚本。wxr中w表示可写，x表示可执行，r表示可读。没有权限时会显示-。此时该脚本的权限为默认的读和写，要手动添加执行权限：chmod u+x *****.sh。有执行权限之后文件夹的颜色由白色变为绿色。


66、使用命令行从redis客户端连接redis集群：./redis-cli -h 192.168.37.131 -p 7006 -c。注意，连接主从节点均可。注意，比连接非集群的redis多了一个-c。（c是集群cluster的首字母）


67、expire a 100 将以a为键的键值对（也就是redis数据库中的键值对）的有效期设置为100s。


68、jedisCluster连接池和jedis连接池不一样的地方是前者不用从连接池中取出连接和将连接还给连接池。他是内部集成好的。事实上jedisCluster是连接对象，不    叫连接池。


69、将配置写在xml配置文件而不是在代码里面写注解的原因：不用重新编译和部署。


70、restful接口风格的五个特点：
                             1）使用http或https协议
                             2）使用专用的域名
                             3）路径中不能有动词只能有名词，名词往往与数据库表格名字相对应
                             4）用http动词进行资源操作（常用的四个是get,post,put,delete）
                             5）用json作为返回数据的格式
                             6）不要使用大写字母
                             7）用中线-代替下划线_
                             8）参数列表被encode过（防止中文参数产生乱码）


71、最佳实践：最佳实践最好应该使用的开发方式，包括使用restful风格的接口和响应设计。restful风格的接口上面介绍过了，相应设计的最佳实践如下：
                      1）响应体仅仅用来传输数据，不要有状态码等其他内容。
                      2）数据要拿来就可以用，不要拆箱（例如不要嵌套json等）
                      3）用来描述数据或者请求的元数据放在header中（也就是响应头中）。（元数据就是描述数据的数据）


72、开发接口的工具：谷歌浏览器里面的Advanced REST client


73、当一台服务器上有多个服务时（也就是有多个service时），zookeeper的端口不用改，dubbo的端口号20880要改，不然会冲突。但是如果使用的是分布式，也就是每个服务都不在一个服务器上的话，就不用改端口号了。


74、web.xml中配置spring（也就是applicationContext.xml文件的路径）和spring监听器。


75、不能同时开启redis配置和redis集群配置不是因为他们都继承的一个接口，而是我们调用的是接口，因此一个接口此时无法对应两个实现类。


76、判断字符串是否为null或者""空字符串的方法：StringUtils.isNotBlank()


77、对象和字符串的相互转换：
                           private static final ObjectMapper MAPPER =new ObjectMapper();
                           1）将对象转换为字符串：String str = MAPPER.writeValueAsString(对象);
                           2）将字符串转换为对象：User user = MAPPER.readValue(str,User.class);


78、在eclipse里面ctrl+h---选择file search 可以进行关键字的搜索。containing text是你要搜索的内容，file name patterns是你要搜索的文件，可以用模糊匹    配。
    ctrl+h是跳转到该文件的指定行数。


79、java的md5加密使用apache包的DigestUtils.md5Hex()方法。


80、redis保证唯一性的方法：incr(aaa)方法，作用是将aaa的值加一。


81、ticket的作用：ticket在用户登陆成功之后存储在cookie中，可以根据ticket从redis数据库中查询到用户的登录信息，从而在分布式集群中不用一直登陆，也可以在用户购物时将用户信息写入订单等位置。


82、linux命令的mv 文件名A 文件名B时代表将文件重命名而不是移动文件。


83、solr索引中，index域查询document域，document域里面有document，document里面有field域。当某个filed域的是否存储选项为否时（也就是field元素的stored属性），他不会出现在field域里面。


84、分词，索引，存储的关系（配置业务域时要使用）：不分词也可能索引，例如价格；索引了也可能不存储，因为可以根据他搜索但是不会展示；不索引也可能存储；不索引的必然不分词，因为分词是为了索引，不索引当然就不用分词了。假如不分词，field业务域中的type是数据类型，分词的话属性值就是分词器名称。另外，业务域的id不能重复。


85、oracle和mysql的区别：前者是基于用户的，后者是基于数据库的。前者是先创建用户再创建表，后者是先创建数据库再创建表。


86、solr单机版和集群版的区别在于后者需要先连接zookeeper再连接solr的collection信息集合。


87、solr的两个分片虽然是分布式，存储的信息是不同的，但是不管从那个分片进行查询，返回的数据都包含所有（分片）的数据。


88、请求进入springmvc的时候会在控制台中显示出来。


89、从数据库中查询数据并添加到索引库的步骤：
                                          1）用mapper从数据库中查询数据
                                          2）把数据封装到SolrInputDocument中（根据schema.xml配置文件中配置的field用addField方法进行封装进行封装）
                                          3）用CloudSolrServer将数据添加到索引库中（调用add方法传入参数SolrInputDocument然后调用commit方法提交）


90、nginx的三个作用：反向代理，图片服务器（文件服务器），集群（可以做到负载均衡）。其中反向代理和图片服务器都是配置映射路径。


91、eclipse里面alt+回车可以显示文件夹的路径


92、防止sql注入的三种方法：页面，服务器，数据库。其中，页面是将关键词替换掉，服务器是将${}变为#{}。
    防止js注入的方法：替换掉关键词，也就是替换掉元素标签（转义掉尖括号。元素名称并不替换）。


93、spring boot省去了java部署的环节，放到服务器上java -jar启动即可（因为里面集成了tomcat）。传统是war部署方式，需要部署到tomcat里面。


94、springboot是spring的一个子项目，能够简化开发，但是该用什么技术还是用什么技术，依然要用到spring。


95、寻找maven的配置文件位置：window--preference--maven--user settings


96、注解和继承的接口重名时（例如springboot的mapper和继承的通用mapper接口）必须有一个是全路径以示区分。


97、分页助手和通用mapper配置在SqlMapConfig.xml中，即使是springboot也要配置。


98、web3.0和2.5的区别在于前者不再有web.xml，也就是没有webapps文件夹。页面资源应该放在那个resources资源文件夹，访问页面时不用再像以前一样从controller跳转，而是直接访问页面即可，页面会调用后台接口，也就是自动访问Controller中的方法。


99、计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母b表示。而计算机最小的存储单元叫“字节（byte）”，通常用大写字母B表示，字节是由连续的8个位组成。


100、基本类型在-128~127的话会在常量池里面，包装类型例如Integer就不行了。


101、栈 存储局部变量
     堆 存储new出来的东西（新new出来的未赋值的数组，基本类型默认为0，引用类型默认为null）
     方法区:
            1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。
            2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。 


102、方法重载特点:与返回值类型无关，只看方法名和参数列表。只要方法名相同并且参数列表不行同，就是方法重载。


103、方法的参数是基本类型的时候：形式参数的改变不影响实际参数。
     方法的参数是引用类型的时候（例如数组）：形式参数的改变影响实际参数。
     原因：基本类型的参数在栈中，用完就被垃圾回收了；引用类型的参数在堆中，用完之后不会马上被回收。


104、数组反转：
              public static void reverse(int[] arr) {
		for(int startIndex=0,endIndex=arr.length-1;startIndex<=endIndex;startIndex++,endIndex--) {
			int temp = arr[startIndex];
			arr[startIndex] = arr[endIndex];
			arr[endIndex] = temp;
		}
	}
}


105、栈的里面是变量和方法，堆的里面是new出来的对象，方法区里面有常量池。


106、private关键字可以修饰成员(成员变量和成员方法)，被private修饰的成员只在本类中才能访问。


107、this关键字：
                A:this:代表所在类的对象引用：方法被哪个对象调用，this就代表那个对象。
                B:什么时候使用this：局部变量和成员变量重名。


108、构造方法的格式：
                    a:方法名与类名相同
                    b:没有返回值类型，连void都没有
                    c:没有具体的返回值（也就是可以有return;只要不加具体的返回值就行）
如果你提供了构造方法，系统将不再提供。
构造方法也是可以重载的,重载条件和普通方法相同（也就是方法名相同，参数的数量或者类型不同）。


109、StringBuilder:
                   StringBuilder:是一个可变的字符串。字符串缓冲区类。  
                   String和StringBuilder的区别：
	                                       String的内容是固定的
	                                       StringBuilder的内容是可变的

String的+=拼接字符串耗费内存原因:
                                 每次拼接都会产生新的字符串对象,而利用StringBuilder来拼接字符串自始至终用的都是同一个StringBuilder容器。


110、FileWriter向文件中写数据：
                //创建输出流对象
		FileWriter fw = new FileWriter("d:\\a.txt");
		/*
		 * 创建输出流对象做了哪些事情:
		 * 		A:调用系统资源创建了一个文件
		 * 		B:创建输出流对象
		 * 		C:把输出流对象指向文件
		 */
		
		//调用输出流对象的写数据的方法
		//写一个字符串数据
		fw.write("IO流你好");
		//数据没有直接写到文件，其实是写到了内存缓冲区
		fw.flush();
		
		//释放资源
		//通知系统释放和该文件相关的资源
		fw.close();

FileWriter的追加写入：
                     FileWriter fw = new FileWriter("c.txt",true); //表示追加写入，默认是false


111、FileReader读数据：
                       //创建输入流对象
//		FileReader fr = new FileReader("fr.txt");
		FileReader fr = new FileReader("FileWriterDemo.java");
		
		//调用输入流对象的读数据方法
		//int read():一次读取一个字符
		
		/*
		
		int ch = fr.read();
		System.out.println(ch);
		System.out.println((char)ch);
		
		//这是时候，我们发现代码的重复度很高，想用循环改进，但是不知道循环的结束条件是什么
		ch = fr.read();
		System.out.println(ch);
		
		ch = fr.read();
		System.out.println(ch);
		//通过测试，我们知道，如果读取数据的返回值是-1的时候，就说明没有数据了，这也是我们循环的结束条件
		*/
		
		int ch;
		//1:fr.read()
		//2:ch=fr.read()
		//3:ch != -1
		while((ch=fr.read())!=-1) {
			//System.out.println(ch);
			//System.out.println((char)ch);
			System.out.print((char)ch);
		}
		
		//释放资源
		fr.close();


112、缓冲流对象BufferedReader()特有的读取数据的方法：readLine()读取一行。传入FileReader做参数。


113、匿名对象：
              匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。例如：new Person();


114、面向对象的三大特性：继承，封装，多态


115、子类调用父类中成员方法的特点：
                                  当在程序中通过对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。


116、方法重写：
              子类方法覆盖（也就是重写）父类方法，必须要保证权限大于等于父类权限。


117、子类与父类出现重名的成员变量和成员方法时：
                                              当子父类中出现了同名成员变量时，在子类中若要访问父类中的成员变量，必须使用关键字super来完成。


118、在每次创建子类对象时，父类的class文件也会进入内存中。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。
     子类的每个构造方法中均有默认的super(),调用父类的空参构造。手动调用父类构造会覆盖默认的super();


119、抽象方法和抽象类：
                      分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么                      此方法就是一个抽象方法。
    定义了抽象函数的类也必须被abstract关键字修饰（也就是有抽象方法的类必然是抽象类），被abstract关键字修饰的类是抽象类。

抽象方法定义的格式：
public abstract 返回值类型 方法名(参数);
抽象类定义的格式：
abstract class 类名 {
}

抽象类无法直接创建对象，只能被子类继承后，创建子类对象。
子类需要继承抽象父类并完成最终的方法实现细节(即重写方法，完成方法体)。

?抽象类一定是个父类，因为抽象类是不断抽取共性需求而来的。
?抽象类中是可以不定义抽象方法的，此时仅仅是不让该类创建对象，用于某些特殊的设计需要。



120、接口：
          ?接口中的方法均为公共访问（也就是public）的抽象方法
?          接口中无法定义普通的成员变量

1、接口中可以定义变量，但是变量必须有固定的修饰符修饰，public static final 所以接口中的变量也称之为常量，其值不能改变。后面我们会讲解static与final关键字
2、接口中可以定义方法，方法也有固定的修饰符，public abstract
3、接口不可以创建对象。
4、子类必须覆盖掉接口中所有的抽象方法后，子类才可以实例化。否则子类是一个抽象类。


121、抽象类和接口的区别:
?                     抽象类为部分方法提供实现,避免子类重复实现这些方法,提高代码重用性;接口只能包含抽象方法;
?                     一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承)
                       抽象类为继承体系中的共性内容,接口为继承体系中的扩展功能


122、多态：
          最终多态体现为父类引用变量可以指向子类对象。
          在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。

父类引用指向子类对象就是多态的定义格式。同一个父类的方法会被不同的子类重写为各自的具体实现。在调用方法时，调用的为各个子类重写后的方法。
父类类型  变量名 = new 子类类型();
变量名.方法名();
此时，虽然该变量指向的是子类对象，但表现为一个父类的形态，可以调用一切父类的方法，子类特有的方法将不能调用。

123、多态的存在意义(优点)为： 
                            配合继承与方法重写提高了代码的复用性与扩展性，如果没有方法重写，则多态同样没有意义。

     多态的弊端:
                 不能调用子类的特有方法。

向上转型就是多态，向下转型（也就是子类转换成父类）是需要强转的。


124、instanceof：java 中的instanceof 运算符是用来在运行时指出对象是否是特定类的一个实例。instanceof通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例。


125、